{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","machina.js","webpack:/webpack/bootstrap c1cc08ba954599b9bd4f","webpack:///src/machina.js","webpack:/external {\"root\":\"_\",\"commonjs\":\"lodash\",\"commonjs2\":\"lodash\",\"amd\":\"lodash\"}","webpack:///src/emitter.js","webpack:///src/utils.js","webpack:///src/events.js","webpack:///src/Fsm.js","webpack:///src/BehavioralFsm.js"],"names":["root","factory","exports","module","require","define","amd","this","__WEBPACK_EXTERNAL_MODULE_1__","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","_","emitter","merge","instance","Fsm","BehavioralFsm","utils","eventListeners","newFsm","getInstance","emit","eventName","args","getLeaklessArgs","arguments","each","callback","useSafeEmit","apply","exception","console","log","stack","slice","on","self","*","push","off","without","getDefaultBehavioralOptions","initialState","states","namespace","makeFsmNamespace","hierarchy","pendingDelegations","getDefaultClientMeta","inputQueue","targetReplayState","state","undefined","priorState","priorAction","currentAction","currentActionArgs","inExitHandler","startIdx","result","i","length","getChildFsmInstance","config","childFsmDefinition","listenToChild","fsm","child","data","events","NO_HANDLER","ticket","delegated","bubbling","inputType","handle","HANDLING","createUUID","s","hexDigits","substr","Math","floor","random","join","machinaCount","_machKeys","extend","protoProps","staticProps","parent","machObj","Ctor","hasOwnProperty","constructor","blendedState","instanceStates","cloneDeep","prototype","transform","accum","val","key","indexOf","__super__","getDefaultOptions","NEXT_TRANSITION","HANDLED","TRANSITION","INVALID_STATE","DEFERRED","NEW_FSM","ensureClientMeta","initClient","Error","transition","_stamped","defaults","ensureClientArg","_args","unshift","splice","getHandlerArgs","isCatchAll","input","buildEventPayload","isPlainObject","methodWithClientInjected","options","initialize","topLevelEmitter","MACHINA_PROP","client","configForState","newState","newStateObj","childListener","_child","concat","inputDef","clientMeta","handlerName","handler","action","currentState","stateObj","eventPayload","delegatedTo","curState","curStateObj","_onExit","fromState","toState","_onEnter","processQueue","attemptedState","deferUntilTransition","stateName","queued","type","untilState","queuedArgs","deferAndTransition","filterFn","item","toProcess","filter","difference","clearQueue","name","evnt","compositeState"],"mappings":"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","file":"machina.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"lodash\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"lodash\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"machina\"] = factory(require(\"lodash\"));\n\telse\n\t\troot[\"machina\"] = factory(root[\"_\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_1__) {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","/*!\n *  * machina - A library for creating powerful and flexible finite state machines. Loosely inspired by Erlang/OTP's gen_fsm behavior.\n *  * Author: Jim Cowart (http://ifandelse.com)\n *  * Version: v1.1.2\n *  * Url: http://machina-js.org/\n *  * License(s): \n */\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"lodash\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"lodash\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"machina\"] = factory(require(\"lodash\"));\n\telse\n\t\troot[\"machina\"] = factory(root[\"_\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_1__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar _ = __webpack_require__( 1 );\n\tvar emitter = __webpack_require__( 2 );\n\t\n\tmodule.exports = _.merge( emitter.instance, {\n\t\tFsm: __webpack_require__( 5 ),\n\t\tBehavioralFsm: __webpack_require__( 6 ),\n\t\tutils: __webpack_require__( 3 ),\n\t\teventListeners: {\n\t\t\tnewFsm: []\n\t\t}\n\t} );\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_1__;\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar utils = __webpack_require__( 3 );\n\t\n\tfunction getInstance() {\n\t\treturn {\n\t\t\temit: function( eventName ) {\n\t\t\t\tvar args = utils.getLeaklessArgs( arguments );\n\t\t\t\tif ( this.eventListeners[ \"*\" ] ) {\n\t\t\t\t\t_.each( this.eventListeners[ \"*\" ], function( callback ) {\n\t\t\t\t\t\tif ( !this.useSafeEmit ) {\n\t\t\t\t\t\t\tcallback.apply( this, args );\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tcallback.apply( this, args );\n\t\t\t\t\t\t\t} catch ( exception ) {\n\t\t\t\t\t\t\t\t/* istanbul ignore else  */\n\t\t\t\t\t\t\t\tif ( console && typeof console.log !== \"undefined\" ) {\n\t\t\t\t\t\t\t\t\tconsole.log( exception.stack );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}, this );\n\t\t\t\t}\n\t\t\t\tif ( this.eventListeners[ eventName ] ) {\n\t\t\t\t\t_.each( this.eventListeners[ eventName ], function( callback ) {\n\t\t\t\t\t\tif ( !this.useSafeEmit ) {\n\t\t\t\t\t\t\tcallback.apply( this, args.slice( 1 ) );\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tcallback.apply( this, args.slice( 1 ) );\n\t\t\t\t\t\t\t} catch ( exception ) {\n\t\t\t\t\t\t\t\t/* istanbul ignore else  */\n\t\t\t\t\t\t\t\tif ( console && typeof console.log !== \"undefined\" ) {\n\t\t\t\t\t\t\t\t\tconsole.log( exception.stack );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}, this );\n\t\t\t\t}\n\t\t\t},\n\t\n\t\t\ton: function( eventName, callback ) {\n\t\t\t\tvar self = this;\n\t\t\t\tself.eventListeners = self.eventListeners || { \"*\": [] };\n\t\t\t\tif ( !self.eventListeners[ eventName ] ) {\n\t\t\t\t\tself.eventListeners[ eventName ] = [];\n\t\t\t\t}\n\t\t\t\tself.eventListeners[ eventName ].push( callback );\n\t\t\t\treturn {\n\t\t\t\t\teventName: eventName,\n\t\t\t\t\tcallback: callback,\n\t\t\t\t\toff: function() {\n\t\t\t\t\t\tself.off( eventName, callback );\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t},\n\t\n\t\t\toff: function( eventName, callback ) {\n\t\t\t\tthis.eventListeners = this.eventListeners || { \"*\": [] };\n\t\t\t\tif ( !eventName ) {\n\t\t\t\t\tthis.eventListeners = {};\n\t\t\t\t} else {\n\t\t\t\t\tif ( callback ) {\n\t\t\t\t\t\tthis.eventListeners[ eventName ] = _.without( this.eventListeners[ eventName ], callback );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.eventListeners[ eventName ] = [];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\t\n\tmodule.exports = {\n\t\tgetInstance: getInstance,\n\t\tinstance: getInstance()\n\t};\n\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar slice = [].slice;\n\tvar events = __webpack_require__( 4 );\n\tvar _ = __webpack_require__( 1 );\n\t\n\tvar makeFsmNamespace = ( function() {\n\t\tvar machinaCount = 0;\n\t\treturn function() {\n\t\t\treturn \"fsm.\" + machinaCount++;\n\t\t};\n\t} )();\n\t\n\tfunction getDefaultBehavioralOptions() {\n\t\treturn {\n\t\t\tinitialState: \"uninitialized\",\n\t\t\teventListeners: {\n\t\t\t\t\"*\": []\n\t\t\t},\n\t\t\tstates: {},\n\t\t\tnamespace: makeFsmNamespace(),\n\t\t\tuseSafeEmit: false,\n\t\t\thierarchy: {},\n\t\t\tpendingDelegations: {}\n\t\t};\n\t}\n\t\n\tfunction getDefaultClientMeta() {\n\t\treturn {\n\t\t\tinputQueue: [],\n\t\t\ttargetReplayState: \"\",\n\t\t\tstate: undefined,\n\t\t\tpriorState: undefined,\n\t\t\tpriorAction: \"\",\n\t\t\tcurrentAction: \"\",\n\t\t\tcurrentActionArgs: undefined,\n\t\t\tinExitHandler: false\n\t\t};\n\t}\n\t\n\tfunction getLeaklessArgs( args, startIdx ) {\n\t\tvar result = [];\n\t\tfor ( var i = ( startIdx || 0 ); i < args.length; i++ ) {\n\t\t\tresult[ i ] = args[ i ];\n\t\t}\n\t\treturn result;\n\t}\n\t/*\n\t\thandle ->\n\t\t\tchild = stateObj._child && stateObj._child.instance;\n\t\n\t\ttransition ->\n\t\t\tnewStateObj._child = getChildFsmInstance( newStateObj._child );\n\t\t\tchild = newStateObj._child && newStateObj._child.instance;\n\t*/\n\tfunction getChildFsmInstance( config ) {\n\t\tif ( !config ) {\n\t\t\treturn;\n\t\t}\n\t\tvar childFsmDefinition = {};\n\t\tif ( typeof config === \"object\" ) {\n\t\t\t// is this a config object with a factory?\n\t\t\tif ( config.factory ) {\n\t\t\t\tchildFsmDefinition = config;\n\t\t\t\tchildFsmDefinition.instance = childFsmDefinition.factory();\n\t\t\t} else {\n\t\t\t\t// assuming this is a machina instance\n\t\t\t\tchildFsmDefinition.factory = function() {\n\t\t\t\t\treturn config;\n\t\t\t\t};\n\t\t\t}\n\t\t} else if ( typeof config === \"function\" ) {\n\t\t\tchildFsmDefinition.factory = config;\n\t\t}\n\t\tchildFsmDefinition.instance = childFsmDefinition.factory();\n\t\treturn childFsmDefinition;\n\t}\n\t\n\tfunction listenToChild( fsm, child ) {\n\t\t// Need to investigate potential for discarded event\n\t\t// listener memory leak in long-running, deeply-nested hierarchies.\n\t\treturn child.on( \"*\", function( eventName, data ) {\n\t\t\tswitch ( eventName ) {\n\t\t\t\tcase events.NO_HANDLER:\n\t\t\t\t\tif ( !data.ticket && !data.delegated && data.namespace !== fsm.namespace ) {\n\t\t\t\t\t\t// Ok - we're dealing w/ a child handling input that should bubble up\n\t\t\t\t\t\tdata.args[ 1 ].bubbling = true;\n\t\t\t\t\t}\n\t\t\t\t\t// we do NOT bubble _reset inputs up to the parent\n\t\t\t\t\tif ( data.inputType !== \"_reset\" ) {\n\t\t\t\t\t\tfsm.handle.apply( fsm, data.args );\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase events.HANDLING :\n\t\t\t\t\tvar ticket = data.ticket;\n\t\t\t\t\tif ( ticket && fsm.pendingDelegations[ ticket ] ) {\n\t\t\t\t\t\tdelete fsm.pendingDelegations[ ticket ];\n\t\t\t\t\t}\n\t\t\t\t\tfsm.emit( eventName, data ); // possibly transform payload?\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tfsm.emit( eventName, data ); // possibly transform payload?\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t} );\n\t}\n\t\n\t// _machKeys are members we want to track across the prototype chain of an extended FSM constructor\n\t// Since we want to eventually merge the aggregate of those values onto the instance so that FSMs\n\t// that share the same extended prototype won't share state *on* those prototypes.\n\tvar _machKeys = [ \"states\", \"initialState\" ];\n\tvar extend = function( protoProps, staticProps ) {\n\t\tvar parent = this;\n\t\tvar fsm; // placeholder for instance constructor\n\t\tvar machObj = {}; // object used to hold initialState & states from prototype for instance-level merging\n\t\tvar Ctor = function() {}; // placeholder ctor function used to insert level in prototype chain\n\t\n\t\t// The constructor function for the new subclass is either defined by you\n\t\t// (the \"constructor\" property in your `extend` definition), or defaulted\n\t\t// by us to simply call the parent's constructor.\n\t\tif ( protoProps && protoProps.hasOwnProperty( \"constructor\" ) ) {\n\t\t\tfsm = protoProps.constructor;\n\t\t} else {\n\t\t\t// The default machina constructor (when using inheritance) creates a\n\t\t\t// deep copy of the states/initialState values from the prototype and\n\t\t\t// extends them over the instance so that they'll be instance-level.\n\t\t\t// If an options arg (args[0]) is passed in, a states or intialState\n\t\t\t// value will be preferred over any data pulled up from the prototype.\n\t\t\tfsm = function() {\n\t\t\t\tvar args = slice.call( arguments, 0 );\n\t\t\t\targs[ 0 ] = args[ 0 ] || {};\n\t\t\t\tvar blendedState;\n\t\t\t\tvar instanceStates = args[ 0 ].states || {};\n\t\t\t\tblendedState = _.merge( _.cloneDeep( machObj ), { states: instanceStates } );\n\t\t\t\tblendedState.initialState = args[ 0 ].initialState || this.initialState;\n\t\t\t\t_.extend( args[ 0 ], blendedState );\n\t\t\t\tparent.apply( this, args );\n\t\t\t};\n\t\t}\n\t\n\t\t// Inherit class (static) properties from parent.\n\t\t_.merge( fsm, parent );\n\t\n\t\t// Set the prototype chain to inherit from `parent`, without calling\n\t\t// `parent`'s constructor function.\n\t\tCtor.prototype = parent.prototype;\n\t\tfsm.prototype = new Ctor();\n\t\n\t\t// Add prototype properties (instance properties) to the subclass,\n\t\t// if supplied.\n\t\tif ( protoProps ) {\n\t\t\t_.extend( fsm.prototype, protoProps );\n\t\t\t_.merge( machObj, _.transform( protoProps, function( accum, val, key ) {\n\t\t\t\tif ( _machKeys.indexOf( key ) !== -1 ) {\n\t\t\t\t\taccum[ key ] = val;\n\t\t\t\t}\n\t\t\t} ) );\n\t\t}\n\t\n\t\t// Add static properties to the constructor function, if supplied.\n\t\tif ( staticProps ) {\n\t\t\t_.merge( fsm, staticProps );\n\t\t}\n\t\n\t\t// Correctly set child's `prototype.constructor`.\n\t\tfsm.prototype.constructor = fsm;\n\t\n\t\t// Set a convenience property in case the parent's prototype is needed later.\n\t\tfsm.__super__ = parent.prototype;\n\t\treturn fsm;\n\t};\n\t\n\tfunction createUUID() {\n\t\tvar s = [];\n\t\tvar hexDigits = \"0123456789abcdef\";\n\t\tfor ( var i = 0; i < 36; i++ ) {\n\t\t\ts[ i ] = hexDigits.substr( Math.floor( Math.random() * 0x10 ), 1 );\n\t\t}\n\t\ts[ 14 ] = \"4\"; // bits 12-15 of the time_hi_and_version field to 0010\n\t\t/* jshint ignore:start */\n\t\ts[ 19 ] = hexDigits.substr( ( s[ 19 ] & 0x3 ) | 0x8, 1 ); // bits 6-7 of the clock_seq_hi_and_reserved to 01\n\t\t/* jshint ignore:end */\n\t\ts[ 8 ] = s[ 13 ] = s[ 18 ] = s[ 23 ] = \"-\";\n\t\treturn s.join( \"\" );\n\t}\n\t\n\tmodule.exports = {\n\t\tcreateUUID: createUUID,\n\t\textend: extend,\n\t\tgetDefaultBehavioralOptions: getDefaultBehavioralOptions,\n\t\tgetDefaultOptions: getDefaultBehavioralOptions,\n\t\tgetDefaultClientMeta: getDefaultClientMeta,\n\t\tgetChildFsmInstance: getChildFsmInstance,\n\t\tgetLeaklessArgs: getLeaklessArgs,\n\t\tlistenToChild: listenToChild,\n\t\tmakeFsmNamespace: makeFsmNamespace\n\t};\n\n\n/***/ },\n/* 4 */\n/***/ function(module, exports) {\n\n\tmodule.exports = {\n\t\tNEXT_TRANSITION: \"transition\",\n\t\tHANDLING: \"handling\",\n\t\tHANDLED: \"handled\",\n\t\tNO_HANDLER: \"nohandler\",\n\t\tTRANSITION: \"transition\",\n\t\tINVALID_STATE: \"invalidstate\",\n\t\tDEFERRED: \"deferred\",\n\t\tNEW_FSM: \"newfsm\"\n\t};\n\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar BehavioralFsm = __webpack_require__( 6 );\n\tvar utils = __webpack_require__( 3 );\n\tvar _ = __webpack_require__( 1 );\n\t\n\tvar Fsm = {\n\t\tconstructor: function() {\n\t\t\tBehavioralFsm.apply( this, arguments );\n\t\t\tthis.ensureClientMeta();\n\t\t},\n\t\tinitClient: function initClient() {\n\t\t\tvar initialState = this.initialState;\n\t\t\tif ( !initialState ) {\n\t\t\t\tthrow new Error( \"You must specify an initial state for this FSM\" );\n\t\t\t}\n\t\t\tif ( !this.states[ initialState ] ) {\n\t\t\t\tthrow new Error( \"The initial state specified does not exist in the states object.\" );\n\t\t\t}\n\t\t\tthis.transition( initialState );\n\t\t},\n\t\tensureClientMeta: function ensureClientMeta() {\n\t\t\tif ( !this._stamped ) {\n\t\t\t\tthis._stamped = true;\n\t\t\t\t_.defaults( this, _.cloneDeep( utils.getDefaultClientMeta() ) );\n\t\t\t\tthis.initClient();\n\t\t\t}\n\t\t\treturn this;\n\t\t},\n\t\n\t\tensureClientArg: function( args ) {\n\t\t\tvar _args = args;\n\t\t\t// we need to test the args and verify that if a client arg has\n\t\t\t// been passed, it must be this FSM instance (this isn't a behavioral FSM)\n\t\t\tif ( typeof _args[ 0 ] === \"object\" && !( \"inputType\" in _args[ 0 ] ) && _args[ 0 ] !== this ) {\n\t\t\t\t_args.splice( 0, 1, this );\n\t\t\t} else if ( typeof _args[ 0 ] !== \"object\" || ( typeof _args[ 0 ] === \"object\" && ( \"inputType\" in _args[ 0 ] ) ) ) {\n\t\t\t\t_args.unshift( this );\n\t\t\t}\n\t\t\treturn _args;\n\t\t},\n\t\n\t\tgetHandlerArgs: function( args, isCatchAll ) {\n\t\t\t// index 0 is the client, index 1 is inputType\n\t\t\t// if we're in a catch-all handler, input type needs to be included in the args\n\t\t\t// inputType might be an object, so we need to just get the inputType string if so\n\t\t\tvar _args = args;\n\t\t\tvar input = _args[ 1 ];\n\t\t\tif ( typeof inputType === \"object\" ) {\n\t\t\t\t_args.splice( 1, 1, input.inputType );\n\t\t\t}\n\t\t\treturn isCatchAll ?\n\t\t\t\t_args.slice( 1 ) :\n\t\t\t\t_args.slice( 2 );\n\t\t},\n\t\t// \"classic\" machina FSM do not emit the client property on events (which would be the FSM itself)\n\t\tbuildEventPayload: function() {\n\t\t\tvar args = this.ensureClientArg( utils.getLeaklessArgs( arguments ) );\n\t\t\tvar data = args[ 1 ];\n\t\t\tif ( _.isPlainObject( data ) ) {\n\t\t\t\treturn _.extend( data, { namespace: this.namespace } );\n\t\t\t} else {\n\t\t\t\treturn { data: data || null, namespace: this.namespace };\n\t\t\t}\n\t\t}\n\t};\n\t\n\t_.each( [\n\t\t\"handle\",\n\t\t\"transition\",\n\t\t\"deferUntilTransition\",\n\t\t\"processQueue\",\n\t\t\"clearQueue\"\n\t], function( methodWithClientInjected ) {\n\t\tFsm[ methodWithClientInjected ] = function() {\n\t\t\tvar args = this.ensureClientArg( utils.getLeaklessArgs( arguments ) );\n\t\t\treturn BehavioralFsm.prototype[ methodWithClientInjected ].apply( this, args );\n\t\t};\n\t} );\n\t\n\tFsm = BehavioralFsm.extend( Fsm );\n\t\n\tmodule.exports = Fsm;\n\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar _ = __webpack_require__( 1 );\n\tvar utils = __webpack_require__( 3 );\n\tvar emitter = __webpack_require__( 2 );\n\tvar topLevelEmitter = emitter.instance;\n\tvar events = __webpack_require__( 4 );\n\t\n\tvar MACHINA_PROP = \"__machina__\";\n\t\n\tfunction BehavioralFsm( options ) {\n\t\t_.extend( this, options );\n\t\t_.defaults( this, utils.getDefaultBehavioralOptions() );\n\t\tthis.initialize.apply( this, arguments );\n\t\ttopLevelEmitter.emit( events.NEW_FSM, this );\n\t}\n\t\n\t_.extend( BehavioralFsm.prototype, {\n\t\tinitialize: function() {},\n\t\n\t\tinitClient: function initClient( client ) {\n\t\t\tvar initialState = this.initialState;\n\t\t\tif ( !initialState ) {\n\t\t\t\tthrow new Error( \"You must specify an initial state for this FSM\" );\n\t\t\t}\n\t\t\tif ( !this.states[ initialState ] ) {\n\t\t\t\tthrow new Error( \"The initial state specified does not exist in the states object.\" );\n\t\t\t}\n\t\t\tthis.transition( client, initialState );\n\t\t},\n\t\n\t\tconfigForState: function configForState( newState ) {\n\t\t\tvar newStateObj = this.states[ newState ];\n\t\t\tvar child;\n\t\t\t_.each( this.hierarchy, function( childListener, key ) {\n\t\t\t\tif ( childListener && typeof childListener.off === \"function\" ) {\n\t\t\t\t\tchildListener.off();\n\t\t\t\t}\n\t\t\t} );\n\t\n\t\t\tif ( newStateObj._child ) {\n\t\t\t\tnewStateObj._child = utils.getChildFsmInstance( newStateObj._child );\n\t\t\t\tchild = newStateObj._child && newStateObj._child.instance;\n\t\t\t\tthis.hierarchy[ child.namespace ] = utils.listenToChild( this, child );\n\t\t\t}\n\t\n\t\t\treturn child;\n\t\t},\n\t\n\t\tensureClientMeta: function ensureClientMeta( client ) {\n\t\t\tif ( typeof client !== \"object\" ) {\n\t\t\t\tthrow new Error( \"An FSM client must be an object.\" );\n\t\t\t}\n\t\t\tclient[ MACHINA_PROP ] = client[ MACHINA_PROP ] || {};\n\t\t\tif ( !client[ MACHINA_PROP ][ this.namespace ] ) {\n\t\t\t\tclient[ MACHINA_PROP ][ this.namespace ] = _.cloneDeep( utils.getDefaultClientMeta() );\n\t\t\t\tthis.initClient( client );\n\t\t\t}\n\t\t\treturn client[ MACHINA_PROP ][ this.namespace ];\n\t\t},\n\t\n\t\tbuildEventPayload: function( client, data ) {\n\t\t\tif ( _.isPlainObject( data ) ) {\n\t\t\t\treturn _.extend( data, { client: client, namespace: this.namespace } );\n\t\t\t} else {\n\t\t\t\treturn { client: client, data: data || null, namespace: this.namespace };\n\t\t\t}\n\t\t},\n\t\n\t\tgetHandlerArgs: function( args, isCatchAll ) {\n\t\t\t// index 0 is the client, index 1 is inputType\n\t\t\t// if we're in a catch-all handler, input type needs to be included in the args\n\t\t\t// inputType might be an object, so we need to just get the inputType string if so\n\t\t\tvar _args = args.slice( 0 );\n\t\t\tvar input = _args[ 1 ];\n\t\t\tif ( typeof input === \"object\" ) {\n\t\t\t\t_args.splice( 1, 1, input.inputType );\n\t\t\t}\n\t\t\treturn isCatchAll ?\n\t\t\t\t_args :\n\t\t\t\t[ _args[ 0 ] ].concat( _args.slice( 2 ) );\n\t\t},\n\t\n\t\thandle: function( client, input ) {\n\t\t\tvar inputDef = input;\n\t\t\tif ( typeof input === \"undefined\" ) {\n\t\t\t\tthrow new Error( \"The input argument passed to the FSM's handle method is undefined. Did you forget to pass the input name?\" );\n\t\t\t}\n\t\t\tif ( typeof input === \"string\" ) {\n\t\t\t\tinputDef = { inputType: input, delegated: false, ticket: undefined };\n\t\t\t}\n\t\t\tvar clientMeta = this.ensureClientMeta( client );\n\t\t\tvar args = utils.getLeaklessArgs( arguments );\n\t\t\tif ( typeof input !== \"object\" ) {\n\t\t\t\targs.splice( 1, 1, inputDef );\n\t\t\t}\n\t\t\tclientMeta.currentActionArgs = args.slice( 1 );\n\t\t\tvar currentState = clientMeta.state;\n\t\t\tvar stateObj = this.states[ currentState ];\n\t\t\tvar handlerName;\n\t\t\tvar handler;\n\t\t\tvar isCatchAll = false;\n\t\t\tvar child;\n\t\t\tvar result;\n\t\t\tvar action;\n\t\t\tif ( !clientMeta.inExitHandler ) {\n\t\t\t\tchild = this.configForState( currentState );\n\t\t\t\tif ( child && !this.pendingDelegations[ inputDef.ticket ] && !inputDef.bubbling ) {\n\t\t\t\t\tinputDef.ticket = ( inputDef.ticket || utils.createUUID() );\n\t\t\t\t\tinputDef.delegated = true;\n\t\t\t\t\tthis.pendingDelegations[ inputDef.ticket ] = { delegatedTo: child.namespace };\n\t\t\t\t\t// WARNING - returning a value from `handle` on child FSMs is not really supported.\n\t\t\t\t\t// If you need to return values from child FSM input handlers, use events instead.\n\t\t\t\t\tresult = child.handle.apply( child, args );\n\t\t\t\t} else {\n\t\t\t\t\tif ( inputDef.ticket && this.pendingDelegations[ inputDef.ticket ] ) {\n\t\t\t\t\t\tdelete this.pendingDelegations[ inputDef.ticket ];\n\t\t\t\t\t}\n\t\t\t\t\thandlerName = stateObj[ inputDef.inputType ] ? inputDef.inputType : \"*\";\n\t\t\t\t\tisCatchAll = ( handlerName === \"*\" );\n\t\t\t\t\thandler = ( stateObj[ handlerName ] || this[ handlerName ] ) || this[ \"*\" ];\n\t\t\t\t\taction = clientMeta.state + \".\" + handlerName;\n\t\t\t\t\tclientMeta.currentAction = action;\n\t\t\t\t\tvar eventPayload = this.buildEventPayload(\n\t\t\t\t\t\tclient,\n\t\t\t\t\t\t{ inputType: inputDef.inputType, delegated: inputDef.delegated, ticket: inputDef.ticket }\n\t\t\t\t\t);\n\t\t\t\t\tif ( !handler ) {\n\t\t\t\t\t\tthis.emit( events.NO_HANDLER, _.extend( { args: args }, eventPayload ) );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.emit( events.HANDLING, eventPayload );\n\t\t\t\t\t\tif ( typeof handler === \"function\" ) {\n\t\t\t\t\t\t\tresult = handler.apply( this, this.getHandlerArgs( args, isCatchAll ) );\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult = handler;\n\t\t\t\t\t\t\tthis.transition( client, handler );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis.emit( events.HANDLED, eventPayload );\n\t\t\t\t\t}\n\t\t\t\t\tclientMeta.priorAction = clientMeta.currentAction;\n\t\t\t\t\tclientMeta.currentAction = \"\";\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t},\n\t\n\t\ttransition: function( client, newState ) {\n\t\t\tvar clientMeta = this.ensureClientMeta( client );\n\t\t\tvar curState = clientMeta.state;\n\t\t\tvar curStateObj = this.states[ curState ];\n\t\t\tvar newStateObj = this.states[ newState ];\n\t\t\tvar child;\n\t\t\tif ( !clientMeta.inExitHandler && newState !== curState ) {\n\t\t\t\tif ( newStateObj ) {\n\t\t\t\t\tchild = this.configForState( newState );\n\t\t\t\t\tif ( curStateObj && curStateObj._onExit ) {\n\t\t\t\t\t\tclientMeta.inExitHandler = true;\n\t\t\t\t\t\tcurStateObj._onExit.call( this, client );\n\t\t\t\t\t\tclientMeta.inExitHandler = false;\n\t\t\t\t\t}\n\t\t\t\t\tclientMeta.targetReplayState = newState;\n\t\t\t\t\tclientMeta.priorState = curState;\n\t\t\t\t\tclientMeta.state = newState;\n\t\t\t\t\tvar eventPayload = this.buildEventPayload( client, {\n\t\t\t\t\t\tfromState: clientMeta.priorState,\n\t\t\t\t\t\taction: clientMeta.currentAction,\n\t\t\t\t\t\ttoState: newState\n\t\t\t\t\t} );\n\t\t\t\t\tthis.emit( events.TRANSITION, eventPayload );\n\t\t\t\t\tif ( newStateObj._onEnter ) {\n\t\t\t\t\t\tnewStateObj._onEnter.call( this, client );\n\t\t\t\t\t}\n\t\t\t\t\tif ( child ) {\n\t\t\t\t\t\tchild.handle( client, \"_reset\" );\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( clientMeta.targetReplayState === newState ) {\n\t\t\t\t\t\tthis.processQueue( client, events.NEXT_TRANSITION );\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tthis.emit( events.INVALID_STATE, this.buildEventPayload( client, {\n\t\t\t\t\tstate: clientMeta.state,\n\t\t\t\t\tattemptedState: newState\n\t\t\t\t} ) );\n\t\t\t}\n\t\t},\n\t\n\t\tdeferUntilTransition: function( client, stateName ) {\n\t\t\tvar clientMeta = this.ensureClientMeta( client );\n\t\t\tif ( clientMeta.currentActionArgs ) {\n\t\t\t\tvar queued = {\n\t\t\t\t\ttype: events.NEXT_TRANSITION,\n\t\t\t\t\tuntilState: stateName,\n\t\t\t\t\targs: clientMeta.currentActionArgs\n\t\t\t\t};\n\t\t\t\tclientMeta.inputQueue.push( queued );\n\t\t\t\tvar eventPayload = this.buildEventPayload( client, {\n\t\t\t\t\tstate: clientMeta.state,\n\t\t\t\t\tqueuedArgs: queued\n\t\t\t\t} );\n\t\t\t\tthis.emit( events.DEFERRED, eventPayload );\n\t\t\t}\n\t\t},\n\t\n\t\tdeferAndTransition: function( client, stateName ) {\n\t\t\tthis.deferUntilTransition( client, stateName );\n\t\t\tthis.transition( client, stateName );\n\t\t},\n\t\n\t\tprocessQueue: function( client ) {\n\t\t\tvar clientMeta = this.ensureClientMeta( client );\n\t\t\tvar filterFn = function( item ) {\n\t\t\t\treturn ( ( !item.untilState ) || ( item.untilState === clientMeta.state ) );\n\t\t\t};\n\t\t\tvar toProcess = _.filter( clientMeta.inputQueue, filterFn );\n\t\t\tclientMeta.inputQueue = _.difference( clientMeta.inputQueue, toProcess );\n\t\t\t_.each( toProcess, function( item ) {\n\t\t\t\tthis.handle.apply( this, [ client ].concat( item.args ) );\n\t\t\t}, this );\n\t\t},\n\t\n\t\tclearQueue: function( client, name ) {\n\t\t\tvar clientMeta = this.ensureClientMeta( client );\n\t\t\tif ( !name ) {\n\t\t\t\tclientMeta.inputQueue = [];\n\t\t\t} else {\n\t\t\t\tvar filter = function( evnt ) {\n\t\t\t\t\treturn ( name ? evnt.untilState !== name : true );\n\t\t\t\t};\n\t\t\t\tclientMeta.inputQueue = _.filter( clientMeta.inputQueue, filter );\n\t\t\t}\n\t\t},\n\t\n\t\tcompositeState: function( client ) {\n\t\t\tvar clientMeta = this.ensureClientMeta( client );\n\t\t\tvar state = clientMeta.state;\n\t\t\tvar child = this.states[state]._child && this.states[state]._child.instance;\n\t\t\tif ( child ) {\n\t\t\t\tstate += \".\" + child.compositeState( client );\n\t\t\t}\n\t\t\treturn state;\n\t\t}\n\t}, emitter.getInstance() );\n\t\n\tBehavioralFsm.extend = utils.extend;\n\t\n\tmodule.exports = BehavioralFsm;\n\n\n/***/ }\n/******/ ])\n});\n;\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwid2VicGFjazovLy93ZWJwYWNrL2Jvb3RzdHJhcCBjMWNjMDhiYTk1NDU5OWI5YmQ0ZiIsIndlYnBhY2s6Ly8vLi9zcmMvbWFjaGluYS5qcyIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwge1wicm9vdFwiOlwiX1wiLFwiY29tbW9uanNcIjpcImxvZGFzaFwiLFwiY29tbW9uanMyXCI6XCJsb2Rhc2hcIixcImFtZFwiOlwibG9kYXNoXCJ9Iiwid2VicGFjazovLy8uL3NyYy9lbWl0dGVyLmpzIiwid2VicGFjazovLy8uL3NyYy91dGlscy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvZXZlbnRzLmpzIiwid2VicGFjazovLy8uL3NyYy9Gc20uanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0JlaGF2aW9yYWxGc20uanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxPO0FDVkE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQWU7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7OztBQ3RDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7Ozs7OztBQ1ZELGdEOzs7Ozs7QUNBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTTtBQUNOO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFNO0FBQ047QUFD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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNILEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDs7QUFFQSIsImZpbGUiOiJtYWNoaW5hLmpzIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKFwibG9kYXNoXCIpKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFtcImxvZGFzaFwiXSwgZmFjdG9yeSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJtYWNoaW5hXCJdID0gZmFjdG9yeShyZXF1aXJlKFwibG9kYXNoXCIpKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJtYWNoaW5hXCJdID0gZmFjdG9yeShyb290W1wiX1wiXSk7XG59KSh0aGlzLCBmdW5jdGlvbihfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzFfXykge1xucmV0dXJuIFxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIHdlYnBhY2svdW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvblxuICoqLyIsIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKVxuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuXG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRleHBvcnRzOiB7fSxcbiBcdFx0XHRpZDogbW9kdWxlSWQsXG4gXHRcdFx0bG9hZGVkOiBmYWxzZVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sb2FkZWQgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogd2VicGFjay9ib290c3RyYXAgYzFjYzA4YmE5NTQ1OTliOWJkNGZcbiAqKi8iLCJ2YXIgXyA9IHJlcXVpcmUoIFwibG9kYXNoXCIgKTtcbnZhciBlbWl0dGVyID0gcmVxdWlyZSggXCIuL2VtaXR0ZXJcIiApO1xuXG5tb2R1bGUuZXhwb3J0cyA9IF8ubWVyZ2UoIGVtaXR0ZXIuaW5zdGFuY2UsIHtcblx0RnNtOiByZXF1aXJlKCBcIi4vRnNtXCIgKSxcblx0QmVoYXZpb3JhbEZzbTogcmVxdWlyZSggXCIuL0JlaGF2aW9yYWxGc21cIiApLFxuXHR1dGlsczogcmVxdWlyZSggXCIuL3V0aWxzXCIgKSxcblx0ZXZlbnRMaXN0ZW5lcnM6IHtcblx0XHRuZXdGc206IFtdXG5cdH1cbn0gKTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvbWFjaGluYS5qc1xuICoqIG1vZHVsZSBpZCA9IDBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV8xX187XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiBleHRlcm5hbCB7XCJyb290XCI6XCJfXCIsXCJjb21tb25qc1wiOlwibG9kYXNoXCIsXCJjb21tb25qczJcIjpcImxvZGFzaFwiLFwiYW1kXCI6XCJsb2Rhc2hcIn1cbiAqKiBtb2R1bGUgaWQgPSAxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgdXRpbHMgPSByZXF1aXJlKCBcIi4vdXRpbHNcIiApO1xuXG5mdW5jdGlvbiBnZXRJbnN0YW5jZSgpIHtcblx0cmV0dXJuIHtcblx0XHRlbWl0OiBmdW5jdGlvbiggZXZlbnROYW1lICkge1xuXHRcdFx0dmFyIGFyZ3MgPSB1dGlscy5nZXRMZWFrbGVzc0FyZ3MoIGFyZ3VtZW50cyApO1xuXHRcdFx0aWYgKCB0aGlzLmV2ZW50TGlzdGVuZXJzWyBcIipcIiBdICkge1xuXHRcdFx0XHRfLmVhY2goIHRoaXMuZXZlbnRMaXN0ZW5lcnNbIFwiKlwiIF0sIGZ1bmN0aW9uKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRpZiAoICF0aGlzLnVzZVNhZmVFbWl0ICkge1xuXHRcdFx0XHRcdFx0Y2FsbGJhY2suYXBwbHkoIHRoaXMsIGFyZ3MgKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdFx0Y2FsbGJhY2suYXBwbHkoIHRoaXMsIGFyZ3MgKTtcblx0XHRcdFx0XHRcdH0gY2F0Y2ggKCBleGNlcHRpb24gKSB7XG5cdFx0XHRcdFx0XHRcdC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICAqL1xuXHRcdFx0XHRcdFx0XHRpZiAoIGNvbnNvbGUgJiYgdHlwZW9mIGNvbnNvbGUubG9nICE9PSBcInVuZGVmaW5lZFwiICkge1xuXHRcdFx0XHRcdFx0XHRcdGNvbnNvbGUubG9nKCBleGNlcHRpb24uc3RhY2sgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSwgdGhpcyApO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCB0aGlzLmV2ZW50TGlzdGVuZXJzWyBldmVudE5hbWUgXSApIHtcblx0XHRcdFx0Xy5lYWNoKCB0aGlzLmV2ZW50TGlzdGVuZXJzWyBldmVudE5hbWUgXSwgZnVuY3Rpb24oIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdGlmICggIXRoaXMudXNlU2FmZUVtaXQgKSB7XG5cdFx0XHRcdFx0XHRjYWxsYmFjay5hcHBseSggdGhpcywgYXJncy5zbGljZSggMSApICk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRcdGNhbGxiYWNrLmFwcGx5KCB0aGlzLCBhcmdzLnNsaWNlKCAxICkgKTtcblx0XHRcdFx0XHRcdH0gY2F0Y2ggKCBleGNlcHRpb24gKSB7XG5cdFx0XHRcdFx0XHRcdC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICAqL1xuXHRcdFx0XHRcdFx0XHRpZiAoIGNvbnNvbGUgJiYgdHlwZW9mIGNvbnNvbGUubG9nICE9PSBcInVuZGVmaW5lZFwiICkge1xuXHRcdFx0XHRcdFx0XHRcdGNvbnNvbGUubG9nKCBleGNlcHRpb24uc3RhY2sgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSwgdGhpcyApO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRvbjogZnVuY3Rpb24oIGV2ZW50TmFtZSwgY2FsbGJhY2sgKSB7XG5cdFx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0XHRzZWxmLmV2ZW50TGlzdGVuZXJzID0gc2VsZi5ldmVudExpc3RlbmVycyB8fCB7IFwiKlwiOiBbXSB9O1xuXHRcdFx0aWYgKCAhc2VsZi5ldmVudExpc3RlbmVyc1sgZXZlbnROYW1lIF0gKSB7XG5cdFx0XHRcdHNlbGYuZXZlbnRMaXN0ZW5lcnNbIGV2ZW50TmFtZSBdID0gW107XG5cdFx0XHR9XG5cdFx0XHRzZWxmLmV2ZW50TGlzdGVuZXJzWyBldmVudE5hbWUgXS5wdXNoKCBjYWxsYmFjayApO1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0ZXZlbnROYW1lOiBldmVudE5hbWUsXG5cdFx0XHRcdGNhbGxiYWNrOiBjYWxsYmFjayxcblx0XHRcdFx0b2ZmOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRzZWxmLm9mZiggZXZlbnROYW1lLCBjYWxsYmFjayApO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdH0sXG5cblx0XHRvZmY6IGZ1bmN0aW9uKCBldmVudE5hbWUsIGNhbGxiYWNrICkge1xuXHRcdFx0dGhpcy5ldmVudExpc3RlbmVycyA9IHRoaXMuZXZlbnRMaXN0ZW5lcnMgfHwgeyBcIipcIjogW10gfTtcblx0XHRcdGlmICggIWV2ZW50TmFtZSApIHtcblx0XHRcdFx0dGhpcy5ldmVudExpc3RlbmVycyA9IHt9O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHR0aGlzLmV2ZW50TGlzdGVuZXJzWyBldmVudE5hbWUgXSA9IF8ud2l0aG91dCggdGhpcy5ldmVudExpc3RlbmVyc1sgZXZlbnROYW1lIF0sIGNhbGxiYWNrICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhpcy5ldmVudExpc3RlbmVyc1sgZXZlbnROYW1lIF0gPSBbXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cdGdldEluc3RhbmNlOiBnZXRJbnN0YW5jZSxcblx0aW5zdGFuY2U6IGdldEluc3RhbmNlKClcbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL2VtaXR0ZXIuanNcbiAqKiBtb2R1bGUgaWQgPSAyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgc2xpY2UgPSBbXS5zbGljZTtcbnZhciBldmVudHMgPSByZXF1aXJlKCBcIi4vZXZlbnRzLmpzXCIgKTtcbnZhciBfID0gcmVxdWlyZSggXCJsb2Rhc2hcIiApO1xuXG52YXIgbWFrZUZzbU5hbWVzcGFjZSA9ICggZnVuY3Rpb24oKSB7XG5cdHZhciBtYWNoaW5hQ291bnQgPSAwO1xuXHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIFwiZnNtLlwiICsgbWFjaGluYUNvdW50Kys7XG5cdH07XG59ICkoKTtcblxuZnVuY3Rpb24gZ2V0RGVmYXVsdEJlaGF2aW9yYWxPcHRpb25zKCkge1xuXHRyZXR1cm4ge1xuXHRcdGluaXRpYWxTdGF0ZTogXCJ1bmluaXRpYWxpemVkXCIsXG5cdFx0ZXZlbnRMaXN0ZW5lcnM6IHtcblx0XHRcdFwiKlwiOiBbXVxuXHRcdH0sXG5cdFx0c3RhdGVzOiB7fSxcblx0XHRuYW1lc3BhY2U6IG1ha2VGc21OYW1lc3BhY2UoKSxcblx0XHR1c2VTYWZlRW1pdDogZmFsc2UsXG5cdFx0aGllcmFyY2h5OiB7fSxcblx0XHRwZW5kaW5nRGVsZWdhdGlvbnM6IHt9XG5cdH07XG59XG5cbmZ1bmN0aW9uIGdldERlZmF1bHRDbGllbnRNZXRhKCkge1xuXHRyZXR1cm4ge1xuXHRcdGlucHV0UXVldWU6IFtdLFxuXHRcdHRhcmdldFJlcGxheVN0YXRlOiBcIlwiLFxuXHRcdHN0YXRlOiB1bmRlZmluZWQsXG5cdFx0cHJpb3JTdGF0ZTogdW5kZWZpbmVkLFxuXHRcdHByaW9yQWN0aW9uOiBcIlwiLFxuXHRcdGN1cnJlbnRBY3Rpb246IFwiXCIsXG5cdFx0Y3VycmVudEFjdGlvbkFyZ3M6IHVuZGVmaW5lZCxcblx0XHRpbkV4aXRIYW5kbGVyOiBmYWxzZVxuXHR9O1xufVxuXG5mdW5jdGlvbiBnZXRMZWFrbGVzc0FyZ3MoIGFyZ3MsIHN0YXJ0SWR4ICkge1xuXHR2YXIgcmVzdWx0ID0gW107XG5cdGZvciAoIHZhciBpID0gKCBzdGFydElkeCB8fCAwICk7IGkgPCBhcmdzLmxlbmd0aDsgaSsrICkge1xuXHRcdHJlc3VsdFsgaSBdID0gYXJnc1sgaSBdO1xuXHR9XG5cdHJldHVybiByZXN1bHQ7XG59XG4vKlxuXHRoYW5kbGUgLT5cblx0XHRjaGlsZCA9IHN0YXRlT2JqLl9jaGlsZCAmJiBzdGF0ZU9iai5fY2hpbGQuaW5zdGFuY2U7XG5cblx0dHJhbnNpdGlvbiAtPlxuXHRcdG5ld1N0YXRlT2JqLl9jaGlsZCA9IGdldENoaWxkRnNtSW5zdGFuY2UoIG5ld1N0YXRlT2JqLl9jaGlsZCApO1xuXHRcdGNoaWxkID0gbmV3U3RhdGVPYmouX2NoaWxkICYmIG5ld1N0YXRlT2JqLl9jaGlsZC5pbnN0YW5jZTtcbiovXG5mdW5jdGlvbiBnZXRDaGlsZEZzbUluc3RhbmNlKCBjb25maWcgKSB7XG5cdGlmICggIWNvbmZpZyApIHtcblx0XHRyZXR1cm47XG5cdH1cblx0dmFyIGNoaWxkRnNtRGVmaW5pdGlvbiA9IHt9O1xuXHRpZiAoIHR5cGVvZiBjb25maWcgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0Ly8gaXMgdGhpcyBhIGNvbmZpZyBvYmplY3Qgd2l0aCBhIGZhY3Rvcnk/XG5cdFx0aWYgKCBjb25maWcuZmFjdG9yeSApIHtcblx0XHRcdGNoaWxkRnNtRGVmaW5pdGlvbiA9IGNvbmZpZztcblx0XHRcdGNoaWxkRnNtRGVmaW5pdGlvbi5pbnN0YW5jZSA9IGNoaWxkRnNtRGVmaW5pdGlvbi5mYWN0b3J5KCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIGFzc3VtaW5nIHRoaXMgaXMgYSBtYWNoaW5hIGluc3RhbmNlXG5cdFx0XHRjaGlsZEZzbURlZmluaXRpb24uZmFjdG9yeSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gY29uZmlnO1xuXHRcdFx0fTtcblx0XHR9XG5cdH0gZWxzZSBpZiAoIHR5cGVvZiBjb25maWcgPT09IFwiZnVuY3Rpb25cIiApIHtcblx0XHRjaGlsZEZzbURlZmluaXRpb24uZmFjdG9yeSA9IGNvbmZpZztcblx0fVxuXHRjaGlsZEZzbURlZmluaXRpb24uaW5zdGFuY2UgPSBjaGlsZEZzbURlZmluaXRpb24uZmFjdG9yeSgpO1xuXHRyZXR1cm4gY2hpbGRGc21EZWZpbml0aW9uO1xufVxuXG5mdW5jdGlvbiBsaXN0ZW5Ub0NoaWxkKCBmc20sIGNoaWxkICkge1xuXHQvLyBOZWVkIHRvIGludmVzdGlnYXRlIHBvdGVudGlhbCBmb3IgZGlzY2FyZGVkIGV2ZW50XG5cdC8vIGxpc3RlbmVyIG1lbW9yeSBsZWFrIGluIGxvbmctcnVubmluZywgZGVlcGx5LW5lc3RlZCBoaWVyYXJjaGllcy5cblx0cmV0dXJuIGNoaWxkLm9uKCBcIipcIiwgZnVuY3Rpb24oIGV2ZW50TmFtZSwgZGF0YSApIHtcblx0XHRzd2l0Y2ggKCBldmVudE5hbWUgKSB7XG5cdFx0XHRjYXNlIGV2ZW50cy5OT19IQU5ETEVSOlxuXHRcdFx0XHRpZiAoICFkYXRhLnRpY2tldCAmJiAhZGF0YS5kZWxlZ2F0ZWQgJiYgZGF0YS5uYW1lc3BhY2UgIT09IGZzbS5uYW1lc3BhY2UgKSB7XG5cdFx0XHRcdFx0Ly8gT2sgLSB3ZSdyZSBkZWFsaW5nIHcvIGEgY2hpbGQgaGFuZGxpbmcgaW5wdXQgdGhhdCBzaG91bGQgYnViYmxlIHVwXG5cdFx0XHRcdFx0ZGF0YS5hcmdzWyAxIF0uYnViYmxpbmcgPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIHdlIGRvIE5PVCBidWJibGUgX3Jlc2V0IGlucHV0cyB1cCB0byB0aGUgcGFyZW50XG5cdFx0XHRcdGlmICggZGF0YS5pbnB1dFR5cGUgIT09IFwiX3Jlc2V0XCIgKSB7XG5cdFx0XHRcdFx0ZnNtLmhhbmRsZS5hcHBseSggZnNtLCBkYXRhLmFyZ3MgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgZXZlbnRzLkhBTkRMSU5HIDpcblx0XHRcdFx0dmFyIHRpY2tldCA9IGRhdGEudGlja2V0O1xuXHRcdFx0XHRpZiAoIHRpY2tldCAmJiBmc20ucGVuZGluZ0RlbGVnYXRpb25zWyB0aWNrZXQgXSApIHtcblx0XHRcdFx0XHRkZWxldGUgZnNtLnBlbmRpbmdEZWxlZ2F0aW9uc1sgdGlja2V0IF07XG5cdFx0XHRcdH1cblx0XHRcdFx0ZnNtLmVtaXQoIGV2ZW50TmFtZSwgZGF0YSApOyAvLyBwb3NzaWJseSB0cmFuc2Zvcm0gcGF5bG9hZD9cblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRmc20uZW1pdCggZXZlbnROYW1lLCBkYXRhICk7IC8vIHBvc3NpYmx5IHRyYW5zZm9ybSBwYXlsb2FkP1xuXHRcdFx0XHRicmVhaztcblx0XHR9XG5cdH0gKTtcbn1cblxuLy8gX21hY2hLZXlzIGFyZSBtZW1iZXJzIHdlIHdhbnQgdG8gdHJhY2sgYWNyb3NzIHRoZSBwcm90b3R5cGUgY2hhaW4gb2YgYW4gZXh0ZW5kZWQgRlNNIGNvbnN0cnVjdG9yXG4vLyBTaW5jZSB3ZSB3YW50IHRvIGV2ZW50dWFsbHkgbWVyZ2UgdGhlIGFnZ3JlZ2F0ZSBvZiB0aG9zZSB2YWx1ZXMgb250byB0aGUgaW5zdGFuY2Ugc28gdGhhdCBGU01zXG4vLyB0aGF0IHNoYXJlIHRoZSBzYW1lIGV4dGVuZGVkIHByb3RvdHlwZSB3b24ndCBzaGFyZSBzdGF0ZSAqb24qIHRob3NlIHByb3RvdHlwZXMuXG52YXIgX21hY2hLZXlzID0gWyBcInN0YXRlc1wiLCBcImluaXRpYWxTdGF0ZVwiIF07XG52YXIgZXh0ZW5kID0gZnVuY3Rpb24oIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzICkge1xuXHR2YXIgcGFyZW50ID0gdGhpcztcblx0dmFyIGZzbTsgLy8gcGxhY2Vob2xkZXIgZm9yIGluc3RhbmNlIGNvbnN0cnVjdG9yXG5cdHZhciBtYWNoT2JqID0ge307IC8vIG9iamVjdCB1c2VkIHRvIGhvbGQgaW5pdGlhbFN0YXRlICYgc3RhdGVzIGZyb20gcHJvdG90eXBlIGZvciBpbnN0YW5jZS1sZXZlbCBtZXJnaW5nXG5cdHZhciBDdG9yID0gZnVuY3Rpb24oKSB7fTsgLy8gcGxhY2Vob2xkZXIgY3RvciBmdW5jdGlvbiB1c2VkIHRvIGluc2VydCBsZXZlbCBpbiBwcm90b3R5cGUgY2hhaW5cblxuXHQvLyBUaGUgY29uc3RydWN0b3IgZnVuY3Rpb24gZm9yIHRoZSBuZXcgc3ViY2xhc3MgaXMgZWl0aGVyIGRlZmluZWQgYnkgeW91XG5cdC8vICh0aGUgXCJjb25zdHJ1Y3RvclwiIHByb3BlcnR5IGluIHlvdXIgYGV4dGVuZGAgZGVmaW5pdGlvbiksIG9yIGRlZmF1bHRlZFxuXHQvLyBieSB1cyB0byBzaW1wbHkgY2FsbCB0aGUgcGFyZW50J3MgY29uc3RydWN0b3IuXG5cdGlmICggcHJvdG9Qcm9wcyAmJiBwcm90b1Byb3BzLmhhc093blByb3BlcnR5KCBcImNvbnN0cnVjdG9yXCIgKSApIHtcblx0XHRmc20gPSBwcm90b1Byb3BzLmNvbnN0cnVjdG9yO1xuXHR9IGVsc2Uge1xuXHRcdC8vIFRoZSBkZWZhdWx0IG1hY2hpbmEgY29uc3RydWN0b3IgKHdoZW4gdXNpbmcgaW5oZXJpdGFuY2UpIGNyZWF0ZXMgYVxuXHRcdC8vIGRlZXAgY29weSBvZiB0aGUgc3RhdGVzL2luaXRpYWxTdGF0ZSB2YWx1ZXMgZnJvbSB0aGUgcHJvdG90eXBlIGFuZFxuXHRcdC8vIGV4dGVuZHMgdGhlbSBvdmVyIHRoZSBpbnN0YW5jZSBzbyB0aGF0IHRoZXknbGwgYmUgaW5zdGFuY2UtbGV2ZWwuXG5cdFx0Ly8gSWYgYW4gb3B0aW9ucyBhcmcgKGFyZ3NbMF0pIGlzIHBhc3NlZCBpbiwgYSBzdGF0ZXMgb3IgaW50aWFsU3RhdGVcblx0XHQvLyB2YWx1ZSB3aWxsIGJlIHByZWZlcnJlZCBvdmVyIGFueSBkYXRhIHB1bGxlZCB1cCBmcm9tIHRoZSBwcm90b3R5cGUuXG5cdFx0ZnNtID0gZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgYXJncyA9IHNsaWNlLmNhbGwoIGFyZ3VtZW50cywgMCApO1xuXHRcdFx0YXJnc1sgMCBdID0gYXJnc1sgMCBdIHx8IHt9O1xuXHRcdFx0dmFyIGJsZW5kZWRTdGF0ZTtcblx0XHRcdHZhciBpbnN0YW5jZVN0YXRlcyA9IGFyZ3NbIDAgXS5zdGF0ZXMgfHwge307XG5cdFx0XHRibGVuZGVkU3RhdGUgPSBfLm1lcmdlKCBfLmNsb25lRGVlcCggbWFjaE9iaiApLCB7IHN0YXRlczogaW5zdGFuY2VTdGF0ZXMgfSApO1xuXHRcdFx0YmxlbmRlZFN0YXRlLmluaXRpYWxTdGF0ZSA9IGFyZ3NbIDAgXS5pbml0aWFsU3RhdGUgfHwgdGhpcy5pbml0aWFsU3RhdGU7XG5cdFx0XHRfLmV4dGVuZCggYXJnc1sgMCBdLCBibGVuZGVkU3RhdGUgKTtcblx0XHRcdHBhcmVudC5hcHBseSggdGhpcywgYXJncyApO1xuXHRcdH07XG5cdH1cblxuXHQvLyBJbmhlcml0IGNsYXNzIChzdGF0aWMpIHByb3BlcnRpZXMgZnJvbSBwYXJlbnQuXG5cdF8ubWVyZ2UoIGZzbSwgcGFyZW50ICk7XG5cblx0Ly8gU2V0IHRoZSBwcm90b3R5cGUgY2hhaW4gdG8gaW5oZXJpdCBmcm9tIGBwYXJlbnRgLCB3aXRob3V0IGNhbGxpbmdcblx0Ly8gYHBhcmVudGAncyBjb25zdHJ1Y3RvciBmdW5jdGlvbi5cblx0Q3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlO1xuXHRmc20ucHJvdG90eXBlID0gbmV3IEN0b3IoKTtcblxuXHQvLyBBZGQgcHJvdG90eXBlIHByb3BlcnRpZXMgKGluc3RhbmNlIHByb3BlcnRpZXMpIHRvIHRoZSBzdWJjbGFzcyxcblx0Ly8gaWYgc3VwcGxpZWQuXG5cdGlmICggcHJvdG9Qcm9wcyApIHtcblx0XHRfLmV4dGVuZCggZnNtLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyApO1xuXHRcdF8ubWVyZ2UoIG1hY2hPYmosIF8udHJhbnNmb3JtKCBwcm90b1Byb3BzLCBmdW5jdGlvbiggYWNjdW0sIHZhbCwga2V5ICkge1xuXHRcdFx0aWYgKCBfbWFjaEtleXMuaW5kZXhPZigga2V5ICkgIT09IC0xICkge1xuXHRcdFx0XHRhY2N1bVsga2V5IF0gPSB2YWw7XG5cdFx0XHR9XG5cdFx0fSApICk7XG5cdH1cblxuXHQvLyBBZGQgc3RhdGljIHByb3BlcnRpZXMgdG8gdGhlIGNvbnN0cnVjdG9yIGZ1bmN0aW9uLCBpZiBzdXBwbGllZC5cblx0aWYgKCBzdGF0aWNQcm9wcyApIHtcblx0XHRfLm1lcmdlKCBmc20sIHN0YXRpY1Byb3BzICk7XG5cdH1cblxuXHQvLyBDb3JyZWN0bHkgc2V0IGNoaWxkJ3MgYHByb3RvdHlwZS5jb25zdHJ1Y3RvcmAuXG5cdGZzbS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBmc207XG5cblx0Ly8gU2V0IGEgY29udmVuaWVuY2UgcHJvcGVydHkgaW4gY2FzZSB0aGUgcGFyZW50J3MgcHJvdG90eXBlIGlzIG5lZWRlZCBsYXRlci5cblx0ZnNtLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7XG5cdHJldHVybiBmc207XG59O1xuXG5mdW5jdGlvbiBjcmVhdGVVVUlEKCkge1xuXHR2YXIgcyA9IFtdO1xuXHR2YXIgaGV4RGlnaXRzID0gXCIwMTIzNDU2Nzg5YWJjZGVmXCI7XG5cdGZvciAoIHZhciBpID0gMDsgaSA8IDM2OyBpKysgKSB7XG5cdFx0c1sgaSBdID0gaGV4RGlnaXRzLnN1YnN0ciggTWF0aC5mbG9vciggTWF0aC5yYW5kb20oKSAqIDB4MTAgKSwgMSApO1xuXHR9XG5cdHNbIDE0IF0gPSBcIjRcIjsgLy8gYml0cyAxMi0xNSBvZiB0aGUgdGltZV9oaV9hbmRfdmVyc2lvbiBmaWVsZCB0byAwMDEwXG5cdC8qIGpzaGludCBpZ25vcmU6c3RhcnQgKi9cblx0c1sgMTkgXSA9IGhleERpZ2l0cy5zdWJzdHIoICggc1sgMTkgXSAmIDB4MyApIHwgMHg4LCAxICk7IC8vIGJpdHMgNi03IG9mIHRoZSBjbG9ja19zZXFfaGlfYW5kX3Jlc2VydmVkIHRvIDAxXG5cdC8qIGpzaGludCBpZ25vcmU6ZW5kICovXG5cdHNbIDggXSA9IHNbIDEzIF0gPSBzWyAxOCBdID0gc1sgMjMgXSA9IFwiLVwiO1xuXHRyZXR1cm4gcy5qb2luKCBcIlwiICk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXHRjcmVhdGVVVUlEOiBjcmVhdGVVVUlELFxuXHRleHRlbmQ6IGV4dGVuZCxcblx0Z2V0RGVmYXVsdEJlaGF2aW9yYWxPcHRpb25zOiBnZXREZWZhdWx0QmVoYXZpb3JhbE9wdGlvbnMsXG5cdGdldERlZmF1bHRPcHRpb25zOiBnZXREZWZhdWx0QmVoYXZpb3JhbE9wdGlvbnMsXG5cdGdldERlZmF1bHRDbGllbnRNZXRhOiBnZXREZWZhdWx0Q2xpZW50TWV0YSxcblx0Z2V0Q2hpbGRGc21JbnN0YW5jZTogZ2V0Q2hpbGRGc21JbnN0YW5jZSxcblx0Z2V0TGVha2xlc3NBcmdzOiBnZXRMZWFrbGVzc0FyZ3MsXG5cdGxpc3RlblRvQ2hpbGQ6IGxpc3RlblRvQ2hpbGQsXG5cdG1ha2VGc21OYW1lc3BhY2U6IG1ha2VGc21OYW1lc3BhY2Vcbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL3V0aWxzLmpzXG4gKiogbW9kdWxlIGlkID0gM1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSB7XG5cdE5FWFRfVFJBTlNJVElPTjogXCJ0cmFuc2l0aW9uXCIsXG5cdEhBTkRMSU5HOiBcImhhbmRsaW5nXCIsXG5cdEhBTkRMRUQ6IFwiaGFuZGxlZFwiLFxuXHROT19IQU5ETEVSOiBcIm5vaGFuZGxlclwiLFxuXHRUUkFOU0lUSU9OOiBcInRyYW5zaXRpb25cIixcblx0SU5WQUxJRF9TVEFURTogXCJpbnZhbGlkc3RhdGVcIixcblx0REVGRVJSRUQ6IFwiZGVmZXJyZWRcIixcblx0TkVXX0ZTTTogXCJuZXdmc21cIlxufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvZXZlbnRzLmpzXG4gKiogbW9kdWxlIGlkID0gNFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIEJlaGF2aW9yYWxGc20gPSByZXF1aXJlKCBcIi4vQmVoYXZpb3JhbEZzbVwiICk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCBcIi4vdXRpbHNcIiApO1xudmFyIF8gPSByZXF1aXJlKCBcImxvZGFzaFwiICk7XG5cbnZhciBGc20gPSB7XG5cdGNvbnN0cnVjdG9yOiBmdW5jdGlvbigpIHtcblx0XHRCZWhhdmlvcmFsRnNtLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHR0aGlzLmVuc3VyZUNsaWVudE1ldGEoKTtcblx0fSxcblx0aW5pdENsaWVudDogZnVuY3Rpb24gaW5pdENsaWVudCgpIHtcblx0XHR2YXIgaW5pdGlhbFN0YXRlID0gdGhpcy5pbml0aWFsU3RhdGU7XG5cdFx0aWYgKCAhaW5pdGlhbFN0YXRlICkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCBcIllvdSBtdXN0IHNwZWNpZnkgYW4gaW5pdGlhbCBzdGF0ZSBmb3IgdGhpcyBGU01cIiApO1xuXHRcdH1cblx0XHRpZiAoICF0aGlzLnN0YXRlc1sgaW5pdGlhbFN0YXRlIF0gKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoIFwiVGhlIGluaXRpYWwgc3RhdGUgc3BlY2lmaWVkIGRvZXMgbm90IGV4aXN0IGluIHRoZSBzdGF0ZXMgb2JqZWN0LlwiICk7XG5cdFx0fVxuXHRcdHRoaXMudHJhbnNpdGlvbiggaW5pdGlhbFN0YXRlICk7XG5cdH0sXG5cdGVuc3VyZUNsaWVudE1ldGE6IGZ1bmN0aW9uIGVuc3VyZUNsaWVudE1ldGEoKSB7XG5cdFx0aWYgKCAhdGhpcy5fc3RhbXBlZCApIHtcblx0XHRcdHRoaXMuX3N0YW1wZWQgPSB0cnVlO1xuXHRcdFx0Xy5kZWZhdWx0cyggdGhpcywgXy5jbG9uZURlZXAoIHV0aWxzLmdldERlZmF1bHRDbGllbnRNZXRhKCkgKSApO1xuXHRcdFx0dGhpcy5pbml0Q2xpZW50KCk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGVuc3VyZUNsaWVudEFyZzogZnVuY3Rpb24oIGFyZ3MgKSB7XG5cdFx0dmFyIF9hcmdzID0gYXJncztcblx0XHQvLyB3ZSBuZWVkIHRvIHRlc3QgdGhlIGFyZ3MgYW5kIHZlcmlmeSB0aGF0IGlmIGEgY2xpZW50IGFyZyBoYXNcblx0XHQvLyBiZWVuIHBhc3NlZCwgaXQgbXVzdCBiZSB0aGlzIEZTTSBpbnN0YW5jZSAodGhpcyBpc24ndCBhIGJlaGF2aW9yYWwgRlNNKVxuXHRcdGlmICggdHlwZW9mIF9hcmdzWyAwIF0gPT09IFwib2JqZWN0XCIgJiYgISggXCJpbnB1dFR5cGVcIiBpbiBfYXJnc1sgMCBdICkgJiYgX2FyZ3NbIDAgXSAhPT0gdGhpcyApIHtcblx0XHRcdF9hcmdzLnNwbGljZSggMCwgMSwgdGhpcyApO1xuXHRcdH0gZWxzZSBpZiAoIHR5cGVvZiBfYXJnc1sgMCBdICE9PSBcIm9iamVjdFwiIHx8ICggdHlwZW9mIF9hcmdzWyAwIF0gPT09IFwib2JqZWN0XCIgJiYgKCBcImlucHV0VHlwZVwiIGluIF9hcmdzWyAwIF0gKSApICkge1xuXHRcdFx0X2FyZ3MudW5zaGlmdCggdGhpcyApO1xuXHRcdH1cblx0XHRyZXR1cm4gX2FyZ3M7XG5cdH0sXG5cblx0Z2V0SGFuZGxlckFyZ3M6IGZ1bmN0aW9uKCBhcmdzLCBpc0NhdGNoQWxsICkge1xuXHRcdC8vIGluZGV4IDAgaXMgdGhlIGNsaWVudCwgaW5kZXggMSBpcyBpbnB1dFR5cGVcblx0XHQvLyBpZiB3ZSdyZSBpbiBhIGNhdGNoLWFsbCBoYW5kbGVyLCBpbnB1dCB0eXBlIG5lZWRzIHRvIGJlIGluY2x1ZGVkIGluIHRoZSBhcmdzXG5cdFx0Ly8gaW5wdXRUeXBlIG1pZ2h0IGJlIGFuIG9iamVjdCwgc28gd2UgbmVlZCB0byBqdXN0IGdldCB0aGUgaW5wdXRUeXBlIHN0cmluZyBpZiBzb1xuXHRcdHZhciBfYXJncyA9IGFyZ3M7XG5cdFx0dmFyIGlucHV0ID0gX2FyZ3NbIDEgXTtcblx0XHRpZiAoIHR5cGVvZiBpbnB1dFR5cGUgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0XHRfYXJncy5zcGxpY2UoIDEsIDEsIGlucHV0LmlucHV0VHlwZSApO1xuXHRcdH1cblx0XHRyZXR1cm4gaXNDYXRjaEFsbCA/XG5cdFx0XHRfYXJncy5zbGljZSggMSApIDpcblx0XHRcdF9hcmdzLnNsaWNlKCAyICk7XG5cdH0sXG5cdC8vIFwiY2xhc3NpY1wiIG1hY2hpbmEgRlNNIGRvIG5vdCBlbWl0IHRoZSBjbGllbnQgcHJvcGVydHkgb24gZXZlbnRzICh3aGljaCB3b3VsZCBiZSB0aGUgRlNNIGl0c2VsZilcblx0YnVpbGRFdmVudFBheWxvYWQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBhcmdzID0gdGhpcy5lbnN1cmVDbGllbnRBcmcoIHV0aWxzLmdldExlYWtsZXNzQXJncyggYXJndW1lbnRzICkgKTtcblx0XHR2YXIgZGF0YSA9IGFyZ3NbIDEgXTtcblx0XHRpZiAoIF8uaXNQbGFpbk9iamVjdCggZGF0YSApICkge1xuXHRcdFx0cmV0dXJuIF8uZXh0ZW5kKCBkYXRhLCB7IG5hbWVzcGFjZTogdGhpcy5uYW1lc3BhY2UgfSApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4geyBkYXRhOiBkYXRhIHx8IG51bGwsIG5hbWVzcGFjZTogdGhpcy5uYW1lc3BhY2UgfTtcblx0XHR9XG5cdH1cbn07XG5cbl8uZWFjaCggW1xuXHRcImhhbmRsZVwiLFxuXHRcInRyYW5zaXRpb25cIixcblx0XCJkZWZlclVudGlsVHJhbnNpdGlvblwiLFxuXHRcInByb2Nlc3NRdWV1ZVwiLFxuXHRcImNsZWFyUXVldWVcIlxuXSwgZnVuY3Rpb24oIG1ldGhvZFdpdGhDbGllbnRJbmplY3RlZCApIHtcblx0RnNtWyBtZXRob2RXaXRoQ2xpZW50SW5qZWN0ZWQgXSA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBhcmdzID0gdGhpcy5lbnN1cmVDbGllbnRBcmcoIHV0aWxzLmdldExlYWtsZXNzQXJncyggYXJndW1lbnRzICkgKTtcblx0XHRyZXR1cm4gQmVoYXZpb3JhbEZzbS5wcm90b3R5cGVbIG1ldGhvZFdpdGhDbGllbnRJbmplY3RlZCBdLmFwcGx5KCB0aGlzLCBhcmdzICk7XG5cdH07XG59ICk7XG5cbkZzbSA9IEJlaGF2aW9yYWxGc20uZXh0ZW5kKCBGc20gKTtcblxubW9kdWxlLmV4cG9ydHMgPSBGc207XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL0ZzbS5qc1xuICoqIG1vZHVsZSBpZCA9IDVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBfID0gcmVxdWlyZSggXCJsb2Rhc2hcIiApO1xudmFyIHV0aWxzID0gcmVxdWlyZSggXCIuL3V0aWxzXCIgKTtcbnZhciBlbWl0dGVyID0gcmVxdWlyZSggXCIuL2VtaXR0ZXJcIiApO1xudmFyIHRvcExldmVsRW1pdHRlciA9IGVtaXR0ZXIuaW5zdGFuY2U7XG52YXIgZXZlbnRzID0gcmVxdWlyZSggXCIuL2V2ZW50c1wiICk7XG5cbnZhciBNQUNISU5BX1BST1AgPSBcIl9fbWFjaGluYV9fXCI7XG5cbmZ1bmN0aW9uIEJlaGF2aW9yYWxGc20oIG9wdGlvbnMgKSB7XG5cdF8uZXh0ZW5kKCB0aGlzLCBvcHRpb25zICk7XG5cdF8uZGVmYXVsdHMoIHRoaXMsIHV0aWxzLmdldERlZmF1bHRCZWhhdmlvcmFsT3B0aW9ucygpICk7XG5cdHRoaXMuaW5pdGlhbGl6ZS5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdHRvcExldmVsRW1pdHRlci5lbWl0KCBldmVudHMuTkVXX0ZTTSwgdGhpcyApO1xufVxuXG5fLmV4dGVuZCggQmVoYXZpb3JhbEZzbS5wcm90b3R5cGUsIHtcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24oKSB7fSxcblxuXHRpbml0Q2xpZW50OiBmdW5jdGlvbiBpbml0Q2xpZW50KCBjbGllbnQgKSB7XG5cdFx0dmFyIGluaXRpYWxTdGF0ZSA9IHRoaXMuaW5pdGlhbFN0YXRlO1xuXHRcdGlmICggIWluaXRpYWxTdGF0ZSApIHtcblx0XHRcdHRocm93IG5ldyBFcnJvciggXCJZb3UgbXVzdCBzcGVjaWZ5IGFuIGluaXRpYWwgc3RhdGUgZm9yIHRoaXMgRlNNXCIgKTtcblx0XHR9XG5cdFx0aWYgKCAhdGhpcy5zdGF0ZXNbIGluaXRpYWxTdGF0ZSBdICkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCBcIlRoZSBpbml0aWFsIHN0YXRlIHNwZWNpZmllZCBkb2VzIG5vdCBleGlzdCBpbiB0aGUgc3RhdGVzIG9iamVjdC5cIiApO1xuXHRcdH1cblx0XHR0aGlzLnRyYW5zaXRpb24oIGNsaWVudCwgaW5pdGlhbFN0YXRlICk7XG5cdH0sXG5cblx0Y29uZmlnRm9yU3RhdGU6IGZ1bmN0aW9uIGNvbmZpZ0ZvclN0YXRlKCBuZXdTdGF0ZSApIHtcblx0XHR2YXIgbmV3U3RhdGVPYmogPSB0aGlzLnN0YXRlc1sgbmV3U3RhdGUgXTtcblx0XHR2YXIgY2hpbGQ7XG5cdFx0Xy5lYWNoKCB0aGlzLmhpZXJhcmNoeSwgZnVuY3Rpb24oIGNoaWxkTGlzdGVuZXIsIGtleSApIHtcblx0XHRcdGlmICggY2hpbGRMaXN0ZW5lciAmJiB0eXBlb2YgY2hpbGRMaXN0ZW5lci5vZmYgPT09IFwiZnVuY3Rpb25cIiApIHtcblx0XHRcdFx0Y2hpbGRMaXN0ZW5lci5vZmYoKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cblx0XHRpZiAoIG5ld1N0YXRlT2JqLl9jaGlsZCApIHtcblx0XHRcdG5ld1N0YXRlT2JqLl9jaGlsZCA9IHV0aWxzLmdldENoaWxkRnNtSW5zdGFuY2UoIG5ld1N0YXRlT2JqLl9jaGlsZCApO1xuXHRcdFx0Y2hpbGQgPSBuZXdTdGF0ZU9iai5fY2hpbGQgJiYgbmV3U3RhdGVPYmouX2NoaWxkLmluc3RhbmNlO1xuXHRcdFx0dGhpcy5oaWVyYXJjaHlbIGNoaWxkLm5hbWVzcGFjZSBdID0gdXRpbHMubGlzdGVuVG9DaGlsZCggdGhpcywgY2hpbGQgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gY2hpbGQ7XG5cdH0sXG5cblx0ZW5zdXJlQ2xpZW50TWV0YTogZnVuY3Rpb24gZW5zdXJlQ2xpZW50TWV0YSggY2xpZW50ICkge1xuXHRcdGlmICggdHlwZW9mIGNsaWVudCAhPT0gXCJvYmplY3RcIiApIHtcblx0XHRcdHRocm93IG5ldyBFcnJvciggXCJBbiBGU00gY2xpZW50IG11c3QgYmUgYW4gb2JqZWN0LlwiICk7XG5cdFx0fVxuXHRcdGNsaWVudFsgTUFDSElOQV9QUk9QIF0gPSBjbGllbnRbIE1BQ0hJTkFfUFJPUCBdIHx8IHt9O1xuXHRcdGlmICggIWNsaWVudFsgTUFDSElOQV9QUk9QIF1bIHRoaXMubmFtZXNwYWNlIF0gKSB7XG5cdFx0XHRjbGllbnRbIE1BQ0hJTkFfUFJPUCBdWyB0aGlzLm5hbWVzcGFjZSBdID0gXy5jbG9uZURlZXAoIHV0aWxzLmdldERlZmF1bHRDbGllbnRNZXRhKCkgKTtcblx0XHRcdHRoaXMuaW5pdENsaWVudCggY2xpZW50ICk7XG5cdFx0fVxuXHRcdHJldHVybiBjbGllbnRbIE1BQ0hJTkFfUFJPUCBdWyB0aGlzLm5hbWVzcGFjZSBdO1xuXHR9LFxuXG5cdGJ1aWxkRXZlbnRQYXlsb2FkOiBmdW5jdGlvbiggY2xpZW50LCBkYXRhICkge1xuXHRcdGlmICggXy5pc1BsYWluT2JqZWN0KCBkYXRhICkgKSB7XG5cdFx0XHRyZXR1cm4gXy5leHRlbmQoIGRhdGEsIHsgY2xpZW50OiBjbGllbnQsIG5hbWVzcGFjZTogdGhpcy5uYW1lc3BhY2UgfSApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4geyBjbGllbnQ6IGNsaWVudCwgZGF0YTogZGF0YSB8fCBudWxsLCBuYW1lc3BhY2U6IHRoaXMubmFtZXNwYWNlIH07XG5cdFx0fVxuXHR9LFxuXG5cdGdldEhhbmRsZXJBcmdzOiBmdW5jdGlvbiggYXJncywgaXNDYXRjaEFsbCApIHtcblx0XHQvLyBpbmRleCAwIGlzIHRoZSBjbGllbnQsIGluZGV4IDEgaXMgaW5wdXRUeXBlXG5cdFx0Ly8gaWYgd2UncmUgaW4gYSBjYXRjaC1hbGwgaGFuZGxlciwgaW5wdXQgdHlwZSBuZWVkcyB0byBiZSBpbmNsdWRlZCBpbiB0aGUgYXJnc1xuXHRcdC8vIGlucHV0VHlwZSBtaWdodCBiZSBhbiBvYmplY3QsIHNvIHdlIG5lZWQgdG8ganVzdCBnZXQgdGhlIGlucHV0VHlwZSBzdHJpbmcgaWYgc29cblx0XHR2YXIgX2FyZ3MgPSBhcmdzLnNsaWNlKCAwICk7XG5cdFx0dmFyIGlucHV0ID0gX2FyZ3NbIDEgXTtcblx0XHRpZiAoIHR5cGVvZiBpbnB1dCA9PT0gXCJvYmplY3RcIiApIHtcblx0XHRcdF9hcmdzLnNwbGljZSggMSwgMSwgaW5wdXQuaW5wdXRUeXBlICk7XG5cdFx0fVxuXHRcdHJldHVybiBpc0NhdGNoQWxsID9cblx0XHRcdF9hcmdzIDpcblx0XHRcdFsgX2FyZ3NbIDAgXSBdLmNvbmNhdCggX2FyZ3Muc2xpY2UoIDIgKSApO1xuXHR9LFxuXG5cdGhhbmRsZTogZnVuY3Rpb24oIGNsaWVudCwgaW5wdXQgKSB7XG5cdFx0dmFyIGlucHV0RGVmID0gaW5wdXQ7XG5cdFx0aWYgKCB0eXBlb2YgaW5wdXQgPT09IFwidW5kZWZpbmVkXCIgKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoIFwiVGhlIGlucHV0IGFyZ3VtZW50IHBhc3NlZCB0byB0aGUgRlNNJ3MgaGFuZGxlIG1ldGhvZCBpcyB1bmRlZmluZWQuIERpZCB5b3UgZm9yZ2V0IHRvIHBhc3MgdGhlIGlucHV0IG5hbWU/XCIgKTtcblx0XHR9XG5cdFx0aWYgKCB0eXBlb2YgaW5wdXQgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRpbnB1dERlZiA9IHsgaW5wdXRUeXBlOiBpbnB1dCwgZGVsZWdhdGVkOiBmYWxzZSwgdGlja2V0OiB1bmRlZmluZWQgfTtcblx0XHR9XG5cdFx0dmFyIGNsaWVudE1ldGEgPSB0aGlzLmVuc3VyZUNsaWVudE1ldGEoIGNsaWVudCApO1xuXHRcdHZhciBhcmdzID0gdXRpbHMuZ2V0TGVha2xlc3NBcmdzKCBhcmd1bWVudHMgKTtcblx0XHRpZiAoIHR5cGVvZiBpbnB1dCAhPT0gXCJvYmplY3RcIiApIHtcblx0XHRcdGFyZ3Muc3BsaWNlKCAxLCAxLCBpbnB1dERlZiApO1xuXHRcdH1cblx0XHRjbGllbnRNZXRhLmN1cnJlbnRBY3Rpb25BcmdzID0gYXJncy5zbGljZSggMSApO1xuXHRcdHZhciBjdXJyZW50U3RhdGUgPSBjbGllbnRNZXRhLnN0YXRlO1xuXHRcdHZhciBzdGF0ZU9iaiA9IHRoaXMuc3RhdGVzWyBjdXJyZW50U3RhdGUgXTtcblx0XHR2YXIgaGFuZGxlck5hbWU7XG5cdFx0dmFyIGhhbmRsZXI7XG5cdFx0dmFyIGlzQ2F0Y2hBbGwgPSBmYWxzZTtcblx0XHR2YXIgY2hpbGQ7XG5cdFx0dmFyIHJlc3VsdDtcblx0XHR2YXIgYWN0aW9uO1xuXHRcdGlmICggIWNsaWVudE1ldGEuaW5FeGl0SGFuZGxlciApIHtcblx0XHRcdGNoaWxkID0gdGhpcy5jb25maWdGb3JTdGF0ZSggY3VycmVudFN0YXRlICk7XG5cdFx0XHRpZiAoIGNoaWxkICYmICF0aGlzLnBlbmRpbmdEZWxlZ2F0aW9uc1sgaW5wdXREZWYudGlja2V0IF0gJiYgIWlucHV0RGVmLmJ1YmJsaW5nICkge1xuXHRcdFx0XHRpbnB1dERlZi50aWNrZXQgPSAoIGlucHV0RGVmLnRpY2tldCB8fCB1dGlscy5jcmVhdGVVVUlEKCkgKTtcblx0XHRcdFx0aW5wdXREZWYuZGVsZWdhdGVkID0gdHJ1ZTtcblx0XHRcdFx0dGhpcy5wZW5kaW5nRGVsZWdhdGlvbnNbIGlucHV0RGVmLnRpY2tldCBdID0geyBkZWxlZ2F0ZWRUbzogY2hpbGQubmFtZXNwYWNlIH07XG5cdFx0XHRcdC8vIFdBUk5JTkcgLSByZXR1cm5pbmcgYSB2YWx1ZSBmcm9tIGBoYW5kbGVgIG9uIGNoaWxkIEZTTXMgaXMgbm90IHJlYWxseSBzdXBwb3J0ZWQuXG5cdFx0XHRcdC8vIElmIHlvdSBuZWVkIHRvIHJldHVybiB2YWx1ZXMgZnJvbSBjaGlsZCBGU00gaW5wdXQgaGFuZGxlcnMsIHVzZSBldmVudHMgaW5zdGVhZC5cblx0XHRcdFx0cmVzdWx0ID0gY2hpbGQuaGFuZGxlLmFwcGx5KCBjaGlsZCwgYXJncyApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKCBpbnB1dERlZi50aWNrZXQgJiYgdGhpcy5wZW5kaW5nRGVsZWdhdGlvbnNbIGlucHV0RGVmLnRpY2tldCBdICkge1xuXHRcdFx0XHRcdGRlbGV0ZSB0aGlzLnBlbmRpbmdEZWxlZ2F0aW9uc1sgaW5wdXREZWYudGlja2V0IF07XG5cdFx0XHRcdH1cblx0XHRcdFx0aGFuZGxlck5hbWUgPSBzdGF0ZU9ialsgaW5wdXREZWYuaW5wdXRUeXBlIF0gPyBpbnB1dERlZi5pbnB1dFR5cGUgOiBcIipcIjtcblx0XHRcdFx0aXNDYXRjaEFsbCA9ICggaGFuZGxlck5hbWUgPT09IFwiKlwiICk7XG5cdFx0XHRcdGhhbmRsZXIgPSAoIHN0YXRlT2JqWyBoYW5kbGVyTmFtZSBdIHx8IHRoaXNbIGhhbmRsZXJOYW1lIF0gKSB8fCB0aGlzWyBcIipcIiBdO1xuXHRcdFx0XHRhY3Rpb24gPSBjbGllbnRNZXRhLnN0YXRlICsgXCIuXCIgKyBoYW5kbGVyTmFtZTtcblx0XHRcdFx0Y2xpZW50TWV0YS5jdXJyZW50QWN0aW9uID0gYWN0aW9uO1xuXHRcdFx0XHR2YXIgZXZlbnRQYXlsb2FkID0gdGhpcy5idWlsZEV2ZW50UGF5bG9hZChcblx0XHRcdFx0XHRjbGllbnQsXG5cdFx0XHRcdFx0eyBpbnB1dFR5cGU6IGlucHV0RGVmLmlucHV0VHlwZSwgZGVsZWdhdGVkOiBpbnB1dERlZi5kZWxlZ2F0ZWQsIHRpY2tldDogaW5wdXREZWYudGlja2V0IH1cblx0XHRcdFx0KTtcblx0XHRcdFx0aWYgKCAhaGFuZGxlciApIHtcblx0XHRcdFx0XHR0aGlzLmVtaXQoIGV2ZW50cy5OT19IQU5ETEVSLCBfLmV4dGVuZCggeyBhcmdzOiBhcmdzIH0sIGV2ZW50UGF5bG9hZCApICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhpcy5lbWl0KCBldmVudHMuSEFORExJTkcsIGV2ZW50UGF5bG9hZCApO1xuXHRcdFx0XHRcdGlmICggdHlwZW9mIGhhbmRsZXIgPT09IFwiZnVuY3Rpb25cIiApIHtcblx0XHRcdFx0XHRcdHJlc3VsdCA9IGhhbmRsZXIuYXBwbHkoIHRoaXMsIHRoaXMuZ2V0SGFuZGxlckFyZ3MoIGFyZ3MsIGlzQ2F0Y2hBbGwgKSApO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRyZXN1bHQgPSBoYW5kbGVyO1xuXHRcdFx0XHRcdFx0dGhpcy50cmFuc2l0aW9uKCBjbGllbnQsIGhhbmRsZXIgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGhpcy5lbWl0KCBldmVudHMuSEFORExFRCwgZXZlbnRQYXlsb2FkICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y2xpZW50TWV0YS5wcmlvckFjdGlvbiA9IGNsaWVudE1ldGEuY3VycmVudEFjdGlvbjtcblx0XHRcdFx0Y2xpZW50TWV0YS5jdXJyZW50QWN0aW9uID0gXCJcIjtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fSxcblxuXHR0cmFuc2l0aW9uOiBmdW5jdGlvbiggY2xpZW50LCBuZXdTdGF0ZSApIHtcblx0XHR2YXIgY2xpZW50TWV0YSA9IHRoaXMuZW5zdXJlQ2xpZW50TWV0YSggY2xpZW50ICk7XG5cdFx0dmFyIGN1clN0YXRlID0gY2xpZW50TWV0YS5zdGF0ZTtcblx0XHR2YXIgY3VyU3RhdGVPYmogPSB0aGlzLnN0YXRlc1sgY3VyU3RhdGUgXTtcblx0XHR2YXIgbmV3U3RhdGVPYmogPSB0aGlzLnN0YXRlc1sgbmV3U3RhdGUgXTtcblx0XHR2YXIgY2hpbGQ7XG5cdFx0aWYgKCAhY2xpZW50TWV0YS5pbkV4aXRIYW5kbGVyICYmIG5ld1N0YXRlICE9PSBjdXJTdGF0ZSApIHtcblx0XHRcdGlmICggbmV3U3RhdGVPYmogKSB7XG5cdFx0XHRcdGNoaWxkID0gdGhpcy5jb25maWdGb3JTdGF0ZSggbmV3U3RhdGUgKTtcblx0XHRcdFx0aWYgKCBjdXJTdGF0ZU9iaiAmJiBjdXJTdGF0ZU9iai5fb25FeGl0ICkge1xuXHRcdFx0XHRcdGNsaWVudE1ldGEuaW5FeGl0SGFuZGxlciA9IHRydWU7XG5cdFx0XHRcdFx0Y3VyU3RhdGVPYmouX29uRXhpdC5jYWxsKCB0aGlzLCBjbGllbnQgKTtcblx0XHRcdFx0XHRjbGllbnRNZXRhLmluRXhpdEhhbmRsZXIgPSBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjbGllbnRNZXRhLnRhcmdldFJlcGxheVN0YXRlID0gbmV3U3RhdGU7XG5cdFx0XHRcdGNsaWVudE1ldGEucHJpb3JTdGF0ZSA9IGN1clN0YXRlO1xuXHRcdFx0XHRjbGllbnRNZXRhLnN0YXRlID0gbmV3U3RhdGU7XG5cdFx0XHRcdHZhciBldmVudFBheWxvYWQgPSB0aGlzLmJ1aWxkRXZlbnRQYXlsb2FkKCBjbGllbnQsIHtcblx0XHRcdFx0XHRmcm9tU3RhdGU6IGNsaWVudE1ldGEucHJpb3JTdGF0ZSxcblx0XHRcdFx0XHRhY3Rpb246IGNsaWVudE1ldGEuY3VycmVudEFjdGlvbixcblx0XHRcdFx0XHR0b1N0YXRlOiBuZXdTdGF0ZVxuXHRcdFx0XHR9ICk7XG5cdFx0XHRcdHRoaXMuZW1pdCggZXZlbnRzLlRSQU5TSVRJT04sIGV2ZW50UGF5bG9hZCApO1xuXHRcdFx0XHRpZiAoIG5ld1N0YXRlT2JqLl9vbkVudGVyICkge1xuXHRcdFx0XHRcdG5ld1N0YXRlT2JqLl9vbkVudGVyLmNhbGwoIHRoaXMsIGNsaWVudCApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggY2hpbGQgKSB7XG5cdFx0XHRcdFx0Y2hpbGQuaGFuZGxlKCBjbGllbnQsIFwiX3Jlc2V0XCIgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggY2xpZW50TWV0YS50YXJnZXRSZXBsYXlTdGF0ZSA9PT0gbmV3U3RhdGUgKSB7XG5cdFx0XHRcdFx0dGhpcy5wcm9jZXNzUXVldWUoIGNsaWVudCwgZXZlbnRzLk5FWFRfVFJBTlNJVElPTiApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdHRoaXMuZW1pdCggZXZlbnRzLklOVkFMSURfU1RBVEUsIHRoaXMuYnVpbGRFdmVudFBheWxvYWQoIGNsaWVudCwge1xuXHRcdFx0XHRzdGF0ZTogY2xpZW50TWV0YS5zdGF0ZSxcblx0XHRcdFx0YXR0ZW1wdGVkU3RhdGU6IG5ld1N0YXRlXG5cdFx0XHR9ICkgKTtcblx0XHR9XG5cdH0sXG5cblx0ZGVmZXJVbnRpbFRyYW5zaXRpb246IGZ1bmN0aW9uKCBjbGllbnQsIHN0YXRlTmFtZSApIHtcblx0XHR2YXIgY2xpZW50TWV0YSA9IHRoaXMuZW5zdXJlQ2xpZW50TWV0YSggY2xpZW50ICk7XG5cdFx0aWYgKCBjbGllbnRNZXRhLmN1cnJlbnRBY3Rpb25BcmdzICkge1xuXHRcdFx0dmFyIHF1ZXVlZCA9IHtcblx0XHRcdFx0dHlwZTogZXZlbnRzLk5FWFRfVFJBTlNJVElPTixcblx0XHRcdFx0dW50aWxTdGF0ZTogc3RhdGVOYW1lLFxuXHRcdFx0XHRhcmdzOiBjbGllbnRNZXRhLmN1cnJlbnRBY3Rpb25BcmdzXG5cdFx0XHR9O1xuXHRcdFx0Y2xpZW50TWV0YS5pbnB1dFF1ZXVlLnB1c2goIHF1ZXVlZCApO1xuXHRcdFx0dmFyIGV2ZW50UGF5bG9hZCA9IHRoaXMuYnVpbGRFdmVudFBheWxvYWQoIGNsaWVudCwge1xuXHRcdFx0XHRzdGF0ZTogY2xpZW50TWV0YS5zdGF0ZSxcblx0XHRcdFx0cXVldWVkQXJnczogcXVldWVkXG5cdFx0XHR9ICk7XG5cdFx0XHR0aGlzLmVtaXQoIGV2ZW50cy5ERUZFUlJFRCwgZXZlbnRQYXlsb2FkICk7XG5cdFx0fVxuXHR9LFxuXG5cdGRlZmVyQW5kVHJhbnNpdGlvbjogZnVuY3Rpb24oIGNsaWVudCwgc3RhdGVOYW1lICkge1xuXHRcdHRoaXMuZGVmZXJVbnRpbFRyYW5zaXRpb24oIGNsaWVudCwgc3RhdGVOYW1lICk7XG5cdFx0dGhpcy50cmFuc2l0aW9uKCBjbGllbnQsIHN0YXRlTmFtZSApO1xuXHR9LFxuXG5cdHByb2Nlc3NRdWV1ZTogZnVuY3Rpb24oIGNsaWVudCApIHtcblx0XHR2YXIgY2xpZW50TWV0YSA9IHRoaXMuZW5zdXJlQ2xpZW50TWV0YSggY2xpZW50ICk7XG5cdFx0dmFyIGZpbHRlckZuID0gZnVuY3Rpb24oIGl0ZW0gKSB7XG5cdFx0XHRyZXR1cm4gKCAoICFpdGVtLnVudGlsU3RhdGUgKSB8fCAoIGl0ZW0udW50aWxTdGF0ZSA9PT0gY2xpZW50TWV0YS5zdGF0ZSApICk7XG5cdFx0fTtcblx0XHR2YXIgdG9Qcm9jZXNzID0gXy5maWx0ZXIoIGNsaWVudE1ldGEuaW5wdXRRdWV1ZSwgZmlsdGVyRm4gKTtcblx0XHRjbGllbnRNZXRhLmlucHV0UXVldWUgPSBfLmRpZmZlcmVuY2UoIGNsaWVudE1ldGEuaW5wdXRRdWV1ZSwgdG9Qcm9jZXNzICk7XG5cdFx0Xy5lYWNoKCB0b1Byb2Nlc3MsIGZ1bmN0aW9uKCBpdGVtICkge1xuXHRcdFx0dGhpcy5oYW5kbGUuYXBwbHkoIHRoaXMsIFsgY2xpZW50IF0uY29uY2F0KCBpdGVtLmFyZ3MgKSApO1xuXHRcdH0sIHRoaXMgKTtcblx0fSxcblxuXHRjbGVhclF1ZXVlOiBmdW5jdGlvbiggY2xpZW50LCBuYW1lICkge1xuXHRcdHZhciBjbGllbnRNZXRhID0gdGhpcy5lbnN1cmVDbGllbnRNZXRhKCBjbGllbnQgKTtcblx0XHRpZiAoICFuYW1lICkge1xuXHRcdFx0Y2xpZW50TWV0YS5pbnB1dFF1ZXVlID0gW107XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBmaWx0ZXIgPSBmdW5jdGlvbiggZXZudCApIHtcblx0XHRcdFx0cmV0dXJuICggbmFtZSA/IGV2bnQudW50aWxTdGF0ZSAhPT0gbmFtZSA6IHRydWUgKTtcblx0XHRcdH07XG5cdFx0XHRjbGllbnRNZXRhLmlucHV0UXVldWUgPSBfLmZpbHRlciggY2xpZW50TWV0YS5pbnB1dFF1ZXVlLCBmaWx0ZXIgKTtcblx0XHR9XG5cdH0sXG5cblx0Y29tcG9zaXRlU3RhdGU6IGZ1bmN0aW9uKCBjbGllbnQgKSB7XG5cdFx0dmFyIGNsaWVudE1ldGEgPSB0aGlzLmVuc3VyZUNsaWVudE1ldGEoIGNsaWVudCApO1xuXHRcdHZhciBzdGF0ZSA9IGNsaWVudE1ldGEuc3RhdGU7XG5cdFx0dmFyIGNoaWxkID0gdGhpcy5zdGF0ZXNbc3RhdGVdLl9jaGlsZCAmJiB0aGlzLnN0YXRlc1tzdGF0ZV0uX2NoaWxkLmluc3RhbmNlO1xuXHRcdGlmICggY2hpbGQgKSB7XG5cdFx0XHRzdGF0ZSArPSBcIi5cIiArIGNoaWxkLmNvbXBvc2l0ZVN0YXRlKCBjbGllbnQgKTtcblx0XHR9XG5cdFx0cmV0dXJuIHN0YXRlO1xuXHR9XG59LCBlbWl0dGVyLmdldEluc3RhbmNlKCkgKTtcblxuQmVoYXZpb3JhbEZzbS5leHRlbmQgPSB1dGlscy5leHRlbmQ7XG5cbm1vZHVsZS5leHBvcnRzID0gQmVoYXZpb3JhbEZzbTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvQmVoYXZpb3JhbEZzbS5qc1xuICoqIG1vZHVsZSBpZCA9IDZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyJdLCJzb3VyY2VSb290IjoiIn0="," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap c1cc08ba954599b9bd4f\n **/","var _ = require( \"lodash\" );\nvar emitter = require( \"./emitter\" );\n\nmodule.exports = _.merge( emitter.instance, {\n\tFsm: require( \"./Fsm\" ),\n\tBehavioralFsm: require( \"./BehavioralFsm\" ),\n\tutils: require( \"./utils\" ),\n\teventListeners: {\n\t\tnewFsm: []\n\t}\n} );\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/machina.js\n ** module id = 0\n ** module chunks = 0\n **/","module.exports = __WEBPACK_EXTERNAL_MODULE_1__;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** external {\"root\":\"_\",\"commonjs\":\"lodash\",\"commonjs2\":\"lodash\",\"amd\":\"lodash\"}\n ** module id = 1\n ** module chunks = 0\n **/","var utils = require( \"./utils\" );\n\nfunction getInstance() {\n\treturn {\n\t\temit: function( eventName ) {\n\t\t\tvar args = utils.getLeaklessArgs( arguments );\n\t\t\tif ( this.eventListeners[ \"*\" ] ) {\n\t\t\t\t_.each( this.eventListeners[ \"*\" ], function( callback ) {\n\t\t\t\t\tif ( !this.useSafeEmit ) {\n\t\t\t\t\t\tcallback.apply( this, args );\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tcallback.apply( this, args );\n\t\t\t\t\t\t} catch ( exception ) {\n\t\t\t\t\t\t\t/* istanbul ignore else  */\n\t\t\t\t\t\t\tif ( console && typeof console.log !== \"undefined\" ) {\n\t\t\t\t\t\t\t\tconsole.log( exception.stack );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}, this );\n\t\t\t}\n\t\t\tif ( this.eventListeners[ eventName ] ) {\n\t\t\t\t_.each( this.eventListeners[ eventName ], function( callback ) {\n\t\t\t\t\tif ( !this.useSafeEmit ) {\n\t\t\t\t\t\tcallback.apply( this, args.slice( 1 ) );\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tcallback.apply( this, args.slice( 1 ) );\n\t\t\t\t\t\t} catch ( exception ) {\n\t\t\t\t\t\t\t/* istanbul ignore else  */\n\t\t\t\t\t\t\tif ( console && typeof console.log !== \"undefined\" ) {\n\t\t\t\t\t\t\t\tconsole.log( exception.stack );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}, this );\n\t\t\t}\n\t\t},\n\n\t\ton: function( eventName, callback ) {\n\t\t\tvar self = this;\n\t\t\tself.eventListeners = self.eventListeners || { \"*\": [] };\n\t\t\tif ( !self.eventListeners[ eventName ] ) {\n\t\t\t\tself.eventListeners[ eventName ] = [];\n\t\t\t}\n\t\t\tself.eventListeners[ eventName ].push( callback );\n\t\t\treturn {\n\t\t\t\teventName: eventName,\n\t\t\t\tcallback: callback,\n\t\t\t\toff: function() {\n\t\t\t\t\tself.off( eventName, callback );\n\t\t\t\t}\n\t\t\t};\n\t\t},\n\n\t\toff: function( eventName, callback ) {\n\t\t\tthis.eventListeners = this.eventListeners || { \"*\": [] };\n\t\t\tif ( !eventName ) {\n\t\t\t\tthis.eventListeners = {};\n\t\t\t} else {\n\t\t\t\tif ( callback ) {\n\t\t\t\t\tthis.eventListeners[ eventName ] = _.without( this.eventListeners[ eventName ], callback );\n\t\t\t\t} else {\n\t\t\t\t\tthis.eventListeners[ eventName ] = [];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n}\n\nmodule.exports = {\n\tgetInstance: getInstance,\n\tinstance: getInstance()\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/emitter.js\n ** module id = 2\n ** module chunks = 0\n **/","var slice = [].slice;\nvar events = require( \"./events.js\" );\nvar _ = require( \"lodash\" );\n\nvar makeFsmNamespace = ( function() {\n\tvar machinaCount = 0;\n\treturn function() {\n\t\treturn \"fsm.\" + machinaCount++;\n\t};\n} )();\n\nfunction getDefaultBehavioralOptions() {\n\treturn {\n\t\tinitialState: \"uninitialized\",\n\t\teventListeners: {\n\t\t\t\"*\": []\n\t\t},\n\t\tstates: {},\n\t\tnamespace: makeFsmNamespace(),\n\t\tuseSafeEmit: false,\n\t\thierarchy: {},\n\t\tpendingDelegations: {}\n\t};\n}\n\nfunction getDefaultClientMeta() {\n\treturn {\n\t\tinputQueue: [],\n\t\ttargetReplayState: \"\",\n\t\tstate: undefined,\n\t\tpriorState: undefined,\n\t\tpriorAction: \"\",\n\t\tcurrentAction: \"\",\n\t\tcurrentActionArgs: undefined,\n\t\tinExitHandler: false\n\t};\n}\n\nfunction getLeaklessArgs( args, startIdx ) {\n\tvar result = [];\n\tfor ( var i = ( startIdx || 0 ); i < args.length; i++ ) {\n\t\tresult[ i ] = args[ i ];\n\t}\n\treturn result;\n}\n/*\n\thandle ->\n\t\tchild = stateObj._child && stateObj._child.instance;\n\n\ttransition ->\n\t\tnewStateObj._child = getChildFsmInstance( newStateObj._child );\n\t\tchild = newStateObj._child && newStateObj._child.instance;\n*/\nfunction getChildFsmInstance( config ) {\n\tif ( !config ) {\n\t\treturn;\n\t}\n\tvar childFsmDefinition = {};\n\tif ( typeof config === \"object\" ) {\n\t\t// is this a config object with a factory?\n\t\tif ( config.factory ) {\n\t\t\tchildFsmDefinition = config;\n\t\t\tchildFsmDefinition.instance = childFsmDefinition.factory();\n\t\t} else {\n\t\t\t// assuming this is a machina instance\n\t\t\tchildFsmDefinition.factory = function() {\n\t\t\t\treturn config;\n\t\t\t};\n\t\t}\n\t} else if ( typeof config === \"function\" ) {\n\t\tchildFsmDefinition.factory = config;\n\t}\n\tchildFsmDefinition.instance = childFsmDefinition.factory();\n\treturn childFsmDefinition;\n}\n\nfunction listenToChild( fsm, child ) {\n\t// Need to investigate potential for discarded event\n\t// listener memory leak in long-running, deeply-nested hierarchies.\n\treturn child.on( \"*\", function( eventName, data ) {\n\t\tswitch ( eventName ) {\n\t\t\tcase events.NO_HANDLER:\n\t\t\t\tif ( !data.ticket && !data.delegated && data.namespace !== fsm.namespace ) {\n\t\t\t\t\t// Ok - we're dealing w/ a child handling input that should bubble up\n\t\t\t\t\tdata.args[ 1 ].bubbling = true;\n\t\t\t\t}\n\t\t\t\t// we do NOT bubble _reset inputs up to the parent\n\t\t\t\tif ( data.inputType !== \"_reset\" ) {\n\t\t\t\t\tfsm.handle.apply( fsm, data.args );\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase events.HANDLING :\n\t\t\t\tvar ticket = data.ticket;\n\t\t\t\tif ( ticket && fsm.pendingDelegations[ ticket ] ) {\n\t\t\t\t\tdelete fsm.pendingDelegations[ ticket ];\n\t\t\t\t}\n\t\t\t\tfsm.emit( eventName, data ); // possibly transform payload?\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tfsm.emit( eventName, data ); // possibly transform payload?\n\t\t\t\tbreak;\n\t\t}\n\t} );\n}\n\n// _machKeys are members we want to track across the prototype chain of an extended FSM constructor\n// Since we want to eventually merge the aggregate of those values onto the instance so that FSMs\n// that share the same extended prototype won't share state *on* those prototypes.\nvar _machKeys = [ \"states\", \"initialState\" ];\nvar extend = function( protoProps, staticProps ) {\n\tvar parent = this;\n\tvar fsm; // placeholder for instance constructor\n\tvar machObj = {}; // object used to hold initialState & states from prototype for instance-level merging\n\tvar Ctor = function() {}; // placeholder ctor function used to insert level in prototype chain\n\n\t// The constructor function for the new subclass is either defined by you\n\t// (the \"constructor\" property in your `extend` definition), or defaulted\n\t// by us to simply call the parent's constructor.\n\tif ( protoProps && protoProps.hasOwnProperty( \"constructor\" ) ) {\n\t\tfsm = protoProps.constructor;\n\t} else {\n\t\t// The default machina constructor (when using inheritance) creates a\n\t\t// deep copy of the states/initialState values from the prototype and\n\t\t// extends them over the instance so that they'll be instance-level.\n\t\t// If an options arg (args[0]) is passed in, a states or intialState\n\t\t// value will be preferred over any data pulled up from the prototype.\n\t\tfsm = function() {\n\t\t\tvar args = slice.call( arguments, 0 );\n\t\t\targs[ 0 ] = args[ 0 ] || {};\n\t\t\tvar blendedState;\n\t\t\tvar instanceStates = args[ 0 ].states || {};\n\t\t\tblendedState = _.merge( _.cloneDeep( machObj ), { states: instanceStates } );\n\t\t\tblendedState.initialState = args[ 0 ].initialState || this.initialState;\n\t\t\t_.extend( args[ 0 ], blendedState );\n\t\t\tparent.apply( this, args );\n\t\t};\n\t}\n\n\t// Inherit class (static) properties from parent.\n\t_.merge( fsm, parent );\n\n\t// Set the prototype chain to inherit from `parent`, without calling\n\t// `parent`'s constructor function.\n\tCtor.prototype = parent.prototype;\n\tfsm.prototype = new Ctor();\n\n\t// Add prototype properties (instance properties) to the subclass,\n\t// if supplied.\n\tif ( protoProps ) {\n\t\t_.extend( fsm.prototype, protoProps );\n\t\t_.merge( machObj, _.transform( protoProps, function( accum, val, key ) {\n\t\t\tif ( _machKeys.indexOf( key ) !== -1 ) {\n\t\t\t\taccum[ key ] = val;\n\t\t\t}\n\t\t} ) );\n\t}\n\n\t// Add static properties to the constructor function, if supplied.\n\tif ( staticProps ) {\n\t\t_.merge( fsm, staticProps );\n\t}\n\n\t// Correctly set child's `prototype.constructor`.\n\tfsm.prototype.constructor = fsm;\n\n\t// Set a convenience property in case the parent's prototype is needed later.\n\tfsm.__super__ = parent.prototype;\n\treturn fsm;\n};\n\nfunction createUUID() {\n\tvar s = [];\n\tvar hexDigits = \"0123456789abcdef\";\n\tfor ( var i = 0; i < 36; i++ ) {\n\t\ts[ i ] = hexDigits.substr( Math.floor( Math.random() * 0x10 ), 1 );\n\t}\n\ts[ 14 ] = \"4\"; // bits 12-15 of the time_hi_and_version field to 0010\n\t/* jshint ignore:start */\n\ts[ 19 ] = hexDigits.substr( ( s[ 19 ] & 0x3 ) | 0x8, 1 ); // bits 6-7 of the clock_seq_hi_and_reserved to 01\n\t/* jshint ignore:end */\n\ts[ 8 ] = s[ 13 ] = s[ 18 ] = s[ 23 ] = \"-\";\n\treturn s.join( \"\" );\n}\n\nmodule.exports = {\n\tcreateUUID: createUUID,\n\textend: extend,\n\tgetDefaultBehavioralOptions: getDefaultBehavioralOptions,\n\tgetDefaultOptions: getDefaultBehavioralOptions,\n\tgetDefaultClientMeta: getDefaultClientMeta,\n\tgetChildFsmInstance: getChildFsmInstance,\n\tgetLeaklessArgs: getLeaklessArgs,\n\tlistenToChild: listenToChild,\n\tmakeFsmNamespace: makeFsmNamespace\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/utils.js\n ** module id = 3\n ** module chunks = 0\n **/","module.exports = {\n\tNEXT_TRANSITION: \"transition\",\n\tHANDLING: \"handling\",\n\tHANDLED: \"handled\",\n\tNO_HANDLER: \"nohandler\",\n\tTRANSITION: \"transition\",\n\tINVALID_STATE: \"invalidstate\",\n\tDEFERRED: \"deferred\",\n\tNEW_FSM: \"newfsm\"\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/events.js\n ** module id = 4\n ** module chunks = 0\n **/","var BehavioralFsm = require( \"./BehavioralFsm\" );\nvar utils = require( \"./utils\" );\nvar _ = require( \"lodash\" );\n\nvar Fsm = {\n\tconstructor: function() {\n\t\tBehavioralFsm.apply( this, arguments );\n\t\tthis.ensureClientMeta();\n\t},\n\tinitClient: function initClient() {\n\t\tvar initialState = this.initialState;\n\t\tif ( !initialState ) {\n\t\t\tthrow new Error( \"You must specify an initial state for this FSM\" );\n\t\t}\n\t\tif ( !this.states[ initialState ] ) {\n\t\t\tthrow new Error( \"The initial state specified does not exist in the states object.\" );\n\t\t}\n\t\tthis.transition( initialState );\n\t},\n\tensureClientMeta: function ensureClientMeta() {\n\t\tif ( !this._stamped ) {\n\t\t\tthis._stamped = true;\n\t\t\t_.defaults( this, _.cloneDeep( utils.getDefaultClientMeta() ) );\n\t\t\tthis.initClient();\n\t\t}\n\t\treturn this;\n\t},\n\n\tensureClientArg: function( args ) {\n\t\tvar _args = args;\n\t\t// we need to test the args and verify that if a client arg has\n\t\t// been passed, it must be this FSM instance (this isn't a behavioral FSM)\n\t\tif ( typeof _args[ 0 ] === \"object\" && !( \"inputType\" in _args[ 0 ] ) && _args[ 0 ] !== this ) {\n\t\t\t_args.splice( 0, 1, this );\n\t\t} else if ( typeof _args[ 0 ] !== \"object\" || ( typeof _args[ 0 ] === \"object\" && ( \"inputType\" in _args[ 0 ] ) ) ) {\n\t\t\t_args.unshift( this );\n\t\t}\n\t\treturn _args;\n\t},\n\n\tgetHandlerArgs: function( args, isCatchAll ) {\n\t\t// index 0 is the client, index 1 is inputType\n\t\t// if we're in a catch-all handler, input type needs to be included in the args\n\t\t// inputType might be an object, so we need to just get the inputType string if so\n\t\tvar _args = args;\n\t\tvar input = _args[ 1 ];\n\t\tif ( typeof inputType === \"object\" ) {\n\t\t\t_args.splice( 1, 1, input.inputType );\n\t\t}\n\t\treturn isCatchAll ?\n\t\t\t_args.slice( 1 ) :\n\t\t\t_args.slice( 2 );\n\t},\n\t// \"classic\" machina FSM do not emit the client property on events (which would be the FSM itself)\n\tbuildEventPayload: function() {\n\t\tvar args = this.ensureClientArg( utils.getLeaklessArgs( arguments ) );\n\t\tvar data = args[ 1 ];\n\t\tif ( _.isPlainObject( data ) ) {\n\t\t\treturn _.extend( data, { namespace: this.namespace } );\n\t\t} else {\n\t\t\treturn { data: data || null, namespace: this.namespace };\n\t\t}\n\t}\n};\n\n_.each( [\n\t\"handle\",\n\t\"transition\",\n\t\"deferUntilTransition\",\n\t\"processQueue\",\n\t\"clearQueue\"\n], function( methodWithClientInjected ) {\n\tFsm[ methodWithClientInjected ] = function() {\n\t\tvar args = this.ensureClientArg( utils.getLeaklessArgs( arguments ) );\n\t\treturn BehavioralFsm.prototype[ methodWithClientInjected ].apply( this, args );\n\t};\n} );\n\nFsm = BehavioralFsm.extend( Fsm );\n\nmodule.exports = Fsm;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/Fsm.js\n ** module id = 5\n ** module chunks = 0\n **/","var _ = require( \"lodash\" );\nvar utils = require( \"./utils\" );\nvar emitter = require( \"./emitter\" );\nvar topLevelEmitter = emitter.instance;\nvar events = require( \"./events\" );\n\nvar MACHINA_PROP = \"__machina__\";\n\nfunction BehavioralFsm( options ) {\n\t_.extend( this, options );\n\t_.defaults( this, utils.getDefaultBehavioralOptions() );\n\tthis.initialize.apply( this, arguments );\n\ttopLevelEmitter.emit( events.NEW_FSM, this );\n}\n\n_.extend( BehavioralFsm.prototype, {\n\tinitialize: function() {},\n\n\tinitClient: function initClient( client ) {\n\t\tvar initialState = this.initialState;\n\t\tif ( !initialState ) {\n\t\t\tthrow new Error( \"You must specify an initial state for this FSM\" );\n\t\t}\n\t\tif ( !this.states[ initialState ] ) {\n\t\t\tthrow new Error( \"The initial state specified does not exist in the states object.\" );\n\t\t}\n\t\tthis.transition( client, initialState );\n\t},\n\n\tconfigForState: function configForState( newState ) {\n\t\tvar newStateObj = this.states[ newState ];\n\t\tvar child;\n\t\t_.each( this.hierarchy, function( childListener, key ) {\n\t\t\tif ( childListener && typeof childListener.off === \"function\" ) {\n\t\t\t\tchildListener.off();\n\t\t\t}\n\t\t} );\n\n\t\tif ( newStateObj._child ) {\n\t\t\tnewStateObj._child = utils.getChildFsmInstance( newStateObj._child );\n\t\t\tchild = newStateObj._child && newStateObj._child.instance;\n\t\t\tthis.hierarchy[ child.namespace ] = utils.listenToChild( this, child );\n\t\t}\n\n\t\treturn child;\n\t},\n\n\tensureClientMeta: function ensureClientMeta( client ) {\n\t\tif ( typeof client !== \"object\" ) {\n\t\t\tthrow new Error( \"An FSM client must be an object.\" );\n\t\t}\n\t\tclient[ MACHINA_PROP ] = client[ MACHINA_PROP ] || {};\n\t\tif ( !client[ MACHINA_PROP ][ this.namespace ] ) {\n\t\t\tclient[ MACHINA_PROP ][ this.namespace ] = _.cloneDeep( utils.getDefaultClientMeta() );\n\t\t\tthis.initClient( client );\n\t\t}\n\t\treturn client[ MACHINA_PROP ][ this.namespace ];\n\t},\n\n\tbuildEventPayload: function( client, data ) {\n\t\tif ( _.isPlainObject( data ) ) {\n\t\t\treturn _.extend( data, { client: client, namespace: this.namespace } );\n\t\t} else {\n\t\t\treturn { client: client, data: data || null, namespace: this.namespace };\n\t\t}\n\t},\n\n\tgetHandlerArgs: function( args, isCatchAll ) {\n\t\t// index 0 is the client, index 1 is inputType\n\t\t// if we're in a catch-all handler, input type needs to be included in the args\n\t\t// inputType might be an object, so we need to just get the inputType string if so\n\t\tvar _args = args.slice( 0 );\n\t\tvar input = _args[ 1 ];\n\t\tif ( typeof input === \"object\" ) {\n\t\t\t_args.splice( 1, 1, input.inputType );\n\t\t}\n\t\treturn isCatchAll ?\n\t\t\t_args :\n\t\t\t[ _args[ 0 ] ].concat( _args.slice( 2 ) );\n\t},\n\n\thandle: function( client, input ) {\n\t\tvar inputDef = input;\n\t\tif ( typeof input === \"undefined\" ) {\n\t\t\tthrow new Error( \"The input argument passed to the FSM's handle method is undefined. Did you forget to pass the input name?\" );\n\t\t}\n\t\tif ( typeof input === \"string\" ) {\n\t\t\tinputDef = { inputType: input, delegated: false, ticket: undefined };\n\t\t}\n\t\tvar clientMeta = this.ensureClientMeta( client );\n\t\tvar args = utils.getLeaklessArgs( arguments );\n\t\tif ( typeof input !== \"object\" ) {\n\t\t\targs.splice( 1, 1, inputDef );\n\t\t}\n\t\tclientMeta.currentActionArgs = args.slice( 1 );\n\t\tvar currentState = clientMeta.state;\n\t\tvar stateObj = this.states[ currentState ];\n\t\tvar handlerName;\n\t\tvar handler;\n\t\tvar isCatchAll = false;\n\t\tvar child;\n\t\tvar result;\n\t\tvar action;\n\t\tif ( !clientMeta.inExitHandler ) {\n\t\t\tchild = this.configForState( currentState );\n\t\t\tif ( child && !this.pendingDelegations[ inputDef.ticket ] && !inputDef.bubbling ) {\n\t\t\t\tinputDef.ticket = ( inputDef.ticket || utils.createUUID() );\n\t\t\t\tinputDef.delegated = true;\n\t\t\t\tthis.pendingDelegations[ inputDef.ticket ] = { delegatedTo: child.namespace };\n\t\t\t\t// WARNING - returning a value from `handle` on child FSMs is not really supported.\n\t\t\t\t// If you need to return values from child FSM input handlers, use events instead.\n\t\t\t\tresult = child.handle.apply( child, args );\n\t\t\t} else {\n\t\t\t\tif ( inputDef.ticket && this.pendingDelegations[ inputDef.ticket ] ) {\n\t\t\t\t\tdelete this.pendingDelegations[ inputDef.ticket ];\n\t\t\t\t}\n\t\t\t\thandlerName = stateObj[ inputDef.inputType ] ? inputDef.inputType : \"*\";\n\t\t\t\tisCatchAll = ( handlerName === \"*\" );\n\t\t\t\thandler = ( stateObj[ handlerName ] || this[ handlerName ] ) || this[ \"*\" ];\n\t\t\t\taction = clientMeta.state + \".\" + handlerName;\n\t\t\t\tclientMeta.currentAction = action;\n\t\t\t\tvar eventPayload = this.buildEventPayload(\n\t\t\t\t\tclient,\n\t\t\t\t\t{ inputType: inputDef.inputType, delegated: inputDef.delegated, ticket: inputDef.ticket }\n\t\t\t\t);\n\t\t\t\tif ( !handler ) {\n\t\t\t\t\tthis.emit( events.NO_HANDLER, _.extend( { args: args }, eventPayload ) );\n\t\t\t\t} else {\n\t\t\t\t\tthis.emit( events.HANDLING, eventPayload );\n\t\t\t\t\tif ( typeof handler === \"function\" ) {\n\t\t\t\t\t\tresult = handler.apply( this, this.getHandlerArgs( args, isCatchAll ) );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult = handler;\n\t\t\t\t\t\tthis.transition( client, handler );\n\t\t\t\t\t}\n\t\t\t\t\tthis.emit( events.HANDLED, eventPayload );\n\t\t\t\t}\n\t\t\t\tclientMeta.priorAction = clientMeta.currentAction;\n\t\t\t\tclientMeta.currentAction = \"\";\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t},\n\n\ttransition: function( client, newState ) {\n\t\tvar clientMeta = this.ensureClientMeta( client );\n\t\tvar curState = clientMeta.state;\n\t\tvar curStateObj = this.states[ curState ];\n\t\tvar newStateObj = this.states[ newState ];\n\t\tvar child;\n\t\tif ( !clientMeta.inExitHandler && newState !== curState ) {\n\t\t\tif ( newStateObj ) {\n\t\t\t\tchild = this.configForState( newState );\n\t\t\t\tif ( curStateObj && curStateObj._onExit ) {\n\t\t\t\t\tclientMeta.inExitHandler = true;\n\t\t\t\t\tcurStateObj._onExit.call( this, client );\n\t\t\t\t\tclientMeta.inExitHandler = false;\n\t\t\t\t}\n\t\t\t\tclientMeta.targetReplayState = newState;\n\t\t\t\tclientMeta.priorState = curState;\n\t\t\t\tclientMeta.state = newState;\n\t\t\t\tvar eventPayload = this.buildEventPayload( client, {\n\t\t\t\t\tfromState: clientMeta.priorState,\n\t\t\t\t\taction: clientMeta.currentAction,\n\t\t\t\t\ttoState: newState\n\t\t\t\t} );\n\t\t\t\tthis.emit( events.TRANSITION, eventPayload );\n\t\t\t\tif ( newStateObj._onEnter ) {\n\t\t\t\t\tnewStateObj._onEnter.call( this, client );\n\t\t\t\t}\n\t\t\t\tif ( child ) {\n\t\t\t\t\tchild.handle( client, \"_reset\" );\n\t\t\t\t}\n\n\t\t\t\tif ( clientMeta.targetReplayState === newState ) {\n\t\t\t\t\tthis.processQueue( client, events.NEXT_TRANSITION );\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis.emit( events.INVALID_STATE, this.buildEventPayload( client, {\n\t\t\t\tstate: clientMeta.state,\n\t\t\t\tattemptedState: newState\n\t\t\t} ) );\n\t\t}\n\t},\n\n\tdeferUntilTransition: function( client, stateName ) {\n\t\tvar clientMeta = this.ensureClientMeta( client );\n\t\tif ( clientMeta.currentActionArgs ) {\n\t\t\tvar queued = {\n\t\t\t\ttype: events.NEXT_TRANSITION,\n\t\t\t\tuntilState: stateName,\n\t\t\t\targs: clientMeta.currentActionArgs\n\t\t\t};\n\t\t\tclientMeta.inputQueue.push( queued );\n\t\t\tvar eventPayload = this.buildEventPayload( client, {\n\t\t\t\tstate: clientMeta.state,\n\t\t\t\tqueuedArgs: queued\n\t\t\t} );\n\t\t\tthis.emit( events.DEFERRED, eventPayload );\n\t\t}\n\t},\n\n\tdeferAndTransition: function( client, stateName ) {\n\t\tthis.deferUntilTransition( client, stateName );\n\t\tthis.transition( client, stateName );\n\t},\n\n\tprocessQueue: function( client ) {\n\t\tvar clientMeta = this.ensureClientMeta( client );\n\t\tvar filterFn = function( item ) {\n\t\t\treturn ( ( !item.untilState ) || ( item.untilState === clientMeta.state ) );\n\t\t};\n\t\tvar toProcess = _.filter( clientMeta.inputQueue, filterFn );\n\t\tclientMeta.inputQueue = _.difference( clientMeta.inputQueue, toProcess );\n\t\t_.each( toProcess, function( item ) {\n\t\t\tthis.handle.apply( this, [ client ].concat( item.args ) );\n\t\t}, this );\n\t},\n\n\tclearQueue: function( client, name ) {\n\t\tvar clientMeta = this.ensureClientMeta( client );\n\t\tif ( !name ) {\n\t\t\tclientMeta.inputQueue = [];\n\t\t} else {\n\t\t\tvar filter = function( evnt ) {\n\t\t\t\treturn ( name ? evnt.untilState !== name : true );\n\t\t\t};\n\t\t\tclientMeta.inputQueue = _.filter( clientMeta.inputQueue, filter );\n\t\t}\n\t},\n\n\tcompositeState: function( client ) {\n\t\tvar clientMeta = this.ensureClientMeta( client );\n\t\tvar state = clientMeta.state;\n\t\tvar child = this.states[state]._child && this.states[state]._child.instance;\n\t\tif ( child ) {\n\t\t\tstate += \".\" + child.compositeState( client );\n\t\t}\n\t\treturn state;\n\t}\n}, emitter.getInstance() );\n\nBehavioralFsm.extend = utils.extend;\n\nmodule.exports = BehavioralFsm;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/BehavioralFsm.js\n ** module id = 6\n ** module chunks = 0\n **/"],"sourceRoot":"/source/"}