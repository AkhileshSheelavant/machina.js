{"name":"Machina.js","body":"# machina.js\r\n\r\n## What is it?\r\nMachina.js is a JavaScript framework for highly customizable finite state machines (FSMs).  Many of the ideas for machina have been very heavily borrowed from the Erlang/OTP FSM behaviors.\r\n\r\n## Why would I use it?\r\n* Finite state machines offer a way to structure web client code in a very organized manner, and can make it much simpler to extend behavior for all or only key edge cases.\r\n\t* For example - instead of nested callbacks/deferreds, use an FSM to act as an \"event aggregator\" that is aware of when state needs to transition in the app once a set of conditions has been satisfied.\r\n\t* FSMs *can* work well for concerns like:\r\n\t\t* app \"init\" (bootstrapping your web client so that certain application behaviors are not available until all appropriate resources/data/behavior are present)\r\n\t\t* persistence concerns - offline vs online.  Abstract persistence behind an fsm that simply listens for messages (commands) to persist data.  Depending on the state of the client (offline vs online), the FSM will handle the activity accordingly - calling code never needs to know.\r\n\t\t* Often-changing-subsets of view or model elements.  Take a navigation menu, for example.  Depending on the context (i.e. - state), you may wish to show/hide certain menu options.  This usually turns out to be a handful of menu show-vs-hide combinations.  An FSM can abstract this well.\r\n* It's simple!  Machina makes the process of organizing the various states your fsm needs to know about, and the kinds of events each state can handle.\r\n* Powerful integration.  By using a plugin like [machina.postal](https://github.com/ifandelse/machina.postal), your FSM instances can auto-wire into [postal.js](https://github.com/ifandelse/postal.js) (a JavaScript message bus), enabling decoupled communications with other components in your application.  This wires up both subscribers (for state handlers to be invoked) and publishers (to publish your FSM's events to the message bus).\r\n* Extend for more power.\r\n\t* Writing your own message bus/eventing wire-up plugin is fairly simple.  Look at [machina.postal](https://github.com/ifandelse/machina.postal) for an example.\r\n\t* Hook into the top level \"newFsm\" event to give other components in your app a handle to your FSM\r\n\r\n## How do I use it?\r\n(Be sure to check out the example folder in this repository for more in-depth demos).\r\n\r\nCreating an FSM:\r\n\r\n```javascript\r\nvar storageFsm = new machina.Fsm({\r\n\tapplicationOffline: function() {\r\n\t\tvar offline = false;\r\n\t\t// checks window.navigator.online and more, sets the offline value\r\n\t\treturn offline;\r\n\t},\r\n\r\n\tverifyState: function( payload ) {\r\n\t\tif( applicationOffline() && this.state !== \"offline\" ) {\r\n\t\t\tthis.offlineMarkerTime = new Date();\r\n\t\t\tthis.transition(\"offline\");\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\telse if ( !applicationOffline() && this.state === \"offline\" ) {\r\n\t\t\tthis.transition( \"online\" );\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\treturn true;\r\n\t},\r\n\r\n\tinitialState: \"offline\",\r\n\r\n\tstates : {\r\n\t\t\"online\" : {\r\n\t\t\t_onEnter: function() {\r\n\t\t\t\tthis.handle(\"sync.customer\");\r\n\t\t\t},\r\n\r\n\t\t\t\"save.customer\" : function( payload ) {\r\n\t\t\t\tif( verifyState( payload ) ) {\r\n                    storage.saveToRemote( payload );\r\n\t\t\t\t}\r\n\t\t\t},\r\n\r\n\t\t\t\"sync.customer\" : function() {\r\n\t\t\t\tif( verifyState( payload ) ) {\r\n\t\t\t\t\tvar unsynced = storage.getFromLocal( { startTime: this.offlineMarkerTime } );\r\n\t\t\t\t\t// Big assumption here!  In the real world,\r\n\t\t\t\t\t// we'd batch this sync in reasonable chunks.\r\n\t\t\t\t\tstorage.saveBatchToRemote( unsynced );\r\n\t\t\t\t\tthis.fireEvent( \"CustomerSyncComplete\", { customers: unsynced } );\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t\"offline\" : {\r\n\t\t\t\"save.customer\" : function( payload ) {\r\n\t\t\t\tif( verifyState( payload ) ) {\r\n                    storage.saveToLocal( payload );\r\n\t\t\t\t}\r\n            }\r\n\t\t}\r\n\t}\r\n});\r\n```\r\n\r\nIn the above example, the developer has created an FSM with two possible states: `online` and `offline`.  While the fsm is in the `online` state, it will respond to `save.customer` and `sync.customer` events.  External code triggers these events by calling the `handle` method on the FSM.  For example `storageFsm.handle( \"sync.customer\", { other: \"data\" } )`.  The `handle` method first looks to see if a named handler exists matching the name of the one passed in, then also checks for a catch-all handler (indicated by the \"*\") if a named handler isn't found.  The `offline` state of the above FSM only responds to `save.customer` events.  If any other type of event name is passed to the `handle` method of the FSM, other than what each state explicitly handles, it is ignored.\r\n\r\nIn addition to the state/handler definitions, the above code example as shows that the FSM will start in the `offline` state, and can generate a `CustomerSyncComplete` event.\r\n\r\nThe `verifyState` and `applicationOffline` methods are custom to this instance of the FSM, and are not, of course, part of machina by default.\r\n\r\nYou can see in the above example that anytime the FSM handles an event, it first checks to see if the state needs to be transitioned between offline and online (via the `verifyState` call).  States can also have an `_onEnter` method - which is fired immediately after the FSM transitions into that state.\r\n\r\nNow that we've seen a quick example, let's do a whirlwind API tour.\r\n\r\n## Whirlwind API Tour\r\nWhen you are creating a new FSM instance, `machina.Fsm` takes 1 argument - an options object.  Here's a breakdown of the members of this `options` object:\r\n\r\n`eventListeners` - Either a list of event names that the FSM can publish, or an object of event names, associated with the array of event handlers subscribed to them.  (You are not required to declare the events your FSM can publish ahead of time - this is only for convenience if you want to add handlers ahead of time.)\r\n\r\n```javascript\r\neventListeners: [\"String\", \"List\", \"ofEvent\", \"names\"]; // this is converted into an object similar to below\r\n// OR\r\neventListeners: {\r\n\tMyEvent1: [],\r\n\tMyEvent2: [function(data) { console.log(data); }]\r\n}\r\n```\r\n\r\n`states` - an object detailing the possible states the FSM can be in, plus the kinds of events/messages each state can handle.  States can have normal \"handlers\" as well as a catch-all handler (\"*\"), and an _onEnter handler invoked when the FSM has transitioned into that state.\r\n\r\n```javascript\r\nstates: {\r\n\t\t\"uninitialized\" : {\r\n\t\t\t_onEnter: function() {\r\n\t\t\t\t// do stuff immediately after we transition into uninitialized\r\n\t\t\t},\r\n\r\n\t\t\t\"initialize\" : function( payload ) {\r\n\t\t\t\t// handle an \"initialize\" event\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t\"ready\" : {\r\n\t\t\t\"*\" : function( payload ) {\r\n\t\t\t\t// any message that comes while in the \"ready\" state will get handled here\r\n\t\t\t\t// unless it matches another \"ready\" handler exactly.\r\n            }\r\n\t\t}\r\n```\r\n\r\n`initialState` - the state in which the FSM will start.  As soon as the instance is created, the FSM calls the `transition` method to transition into this state.\r\n\r\n`namespace` - a name that indentifies the FSM if it's wired up to a message bus through a plugin.\r\n\r\n## The machina.Fsm Prototype\r\nEach instance of an machina FSM has the following methods available via it's prototype:\r\n\r\n* `fireEvent(eventName, [other args...])` - looks in the `events` object for a matching event name, and then iterates through the subscriber callbacks for that event and invokes each one, passing in any additional args that were passed to `fireEvent`.\r\n* `handle(msgType, [other args...])` - This is the main way you should be interacting with an FSM instance (assuming no message bus is present).  It will try to find a matching eventName/msgType under the current state and invoke it, if one exists.  Otherwise it will look for a catch-all handler, or simply ignore the message and raise the \"NoHandler\" event.\r\n* `transition(newState)` - Called when transitioning into a new state.\r\n* `deferUntilTransition(stateName)` - calling this within a state handler function will queue the handler's arguments to be executed at a later time.  If you don't provide the `stateName` argument, it will replay the event after the next state transition.  Providing the `stateName` argument will queue the event until the FSM transitions into that state.\r\n* `deferUntilNextHandler()` - calling this within a state handler function will queue the handler's arguments to be executed after the next handler is invoked.\r\n* `processQueue()` - called internally during state transitions and after handler methods have been invoked.  This call processes any queued events (queued by use of `deferUntilTransition` and/or `deferUntilNextHandler`).\r\n* `on(eventName, callback)` - used to subscribe to events that the FSM generates.\r\n* `off(eventName, callback)` - used to unsubscribe to FSM events.\r\n\r\n## The Top Level machina object\r\nThe top level `machina` object has the following members:\r\n\r\n* `Fsm` - the constructor function used to create FSMs.\r\n* `utils` - contains helper functions that can be overridden to change default behavior(s) in machina:\r\n\t* `getDefaultOptions` - returns the default options object for any machina instance\r\n\t* `makeFsmNamespace` - function that provides a default \"channel\" or \"exchange\" for an FSM instance.  (e.g. - fsm.0, fsm.1, etc.)\r\n* `on` - function used to subscribe a callback to top-level machina events (currently the only event published at this level is \"newFsm\")\r\n* `off` - function used to unsubscribe a callback to top-level machina events.\r\n* `eventListeners` - an object literal containing the top-level `fireEvent` call as well as susbcribers to any top-level events.\r\n\r\n## Release Notes\r\n\r\n### v0.2.0\r\n\r\n* Message bus integration has been removed from machina core, and now exists as plugins.  For integration with [postal.js](https://github.com/ifandelse/postal.js), see [machina.postal](https://github.com/ifandelse/machina.postal)\r\n* Due to the above change, the only \"messaging-related\" metadata on an FSM now is the \"namespace\" value that can be passed as the FSM is created.  This value is optional, and will be given a default if none is provided.  Messaging plugins can utilize this value as a channel/namespace name and/or topic prefix.\r\n* A \"priorState\" member has been added to the Fsm.","tagline":"js ex machina - finite state machines in JavaScript","google":"UA-30321396-1","note":"Don't delete this file! It's used internally to help with page regeneration."}